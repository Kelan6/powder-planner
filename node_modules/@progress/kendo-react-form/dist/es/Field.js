var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { FormContext } from './FormContext';
/**
 * Represents the Field component that is used inside the KendoReact Form component.
 * It uses `name` property to access field value and meta information from Form state.
 */
export var Field = function (props) {
    var name = props.name, component = props.component, validator = props.validator, children = props.children, onChange = props.onChange, others = __rest(props, ["name", "component", "validator", "children", "onChange"]);
    var form = React.useContext(FormContext);
    var formId = form ? form.id : '';
    React.useEffect(function () {
        if (!form) {
            return;
        }
        var unregisterField = form.registerField(name, validator);
        return unregisterField;
    }, [name, formId, validator]);
    var handleOnChange = React.useCallback(function (event) {
        // Adding a name here slows down the performance.
        // However, the other apprach taken by Formik is to search for the `name` attribute
        // on `event.target.value` which does not work for all KendoReact components.
        // If Formik uses custom components like the KendoReact ones, it would take the same approach.
        // On the other hand, ReactFinal Form performs better in both cases due to its
        // subscribtion-based model - the fields are subscribed for changes to a given field,
        // which prevents unnececery rerenders. Note that this might be fragile in future React versions -
        // the current performance testing accunts for a slight lag after 300 native HTML inputs in the 120ms-200ms range.
        var newValue = event
            ? (event.value !== undefined
                ? event.value
                : (event.target
                    ? event.target.value
                    : event.target))
            : event;
        form.onChange(name, { value: newValue });
        if (onChange) {
            onChange.call(undefined, event);
        }
    }, [name, formId, onChange]);
    var onNativeComponentChange = React.useCallback(function (event) { return form.onChange(name, { value: event.target.value }); }, [name, formId]);
    var handleOnBlur = React.useCallback(function () { return form.onBlur(name); }, [name, formId]);
    var handleOnFocus = React.useCallback(function () { return form.onFocus(name); }, [name, formId]);
    if (!form) {
        // TODO: For future versions - warn for missing form in dev mode
        // if (__process.env.NODE_ENV !== 'production') { // or __DEV__
        //     throw new Error('Field must be used inside of a <Form> component');
        // }
        return null;
    }
    var value = form.valueGetter(name);
    // TODO: For future versions as it's better to have render prop
    // if (typeof children === 'function') {
    //     return children({ ...field, children: undefined, ...others });
    // }
    if (typeof component === 'string') {
        // ignore meta, combine input with any other props
        return React.createElement(component, __assign({ onChange: onNativeComponentChange, onBlur: handleOnBlur, onFocus: handleOnFocus, value: value, children: children }, others));
    }
    return React.createElement(component, __assign(__assign({ children: children }, others), { 
        // input
        onChange: handleOnChange, onBlur: handleOnBlur, onFocus: handleOnFocus, value: value, 
        // meta
        validationMessage: form.errors[name], touched: form.touched[name], modified: form.modified[name], visited: form.visited[name], 
        // Our `valid` implementation requires double submit to show html5 validation errors,
        // however it's NOT recommended to show html5 validation errors at all as:
        // - There is no standard way to change validation look and feel with CSS.
        // - Look different in each browser / OS
        // - You can have a page in one language but an error message displayed in another language (not localizable)
        valid: !(Boolean(form.errors[name]) && form.touched[name]), name: name }));
};
Field.displayName = 'KendoReactField';
