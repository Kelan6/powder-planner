var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/** @hidden */
export var last = function (arr) { return arr[arr.length - 1]; };
/** @hidden */
export var toFlatGroupResources = function (resources, index, depth, parents) {
    if (index === void 0) { index = 0; }
    if (depth === void 0) { depth = 0; }
    if (parents === void 0) { parents = []; }
    if (resources.length <= index) {
        return [parents];
    }
    var result = [];
    resources[index].data.map(function (item) {
        result.push.apply(result, toFlatGroupResources(resources, index + 1, depth + 1, __spreadArray(__spreadArray([], parents, true), [__assign(__assign({}, item), { field: resources[index].field, valueField: resources[index].valueField, colorField: resources[index].colorField, multiple: resources[index].multiple })], false)));
    });
    return result;
};
/** @hidden */
export var calculateEventRect = function (slots, vertical) {
    // console.log(slots.length && slots[0]);
    if (slots.length < 1 || !slots[0]._ref || !slots[0]._ref.current) {
        return null;
    }
    var firstSlotRect = getRect(slots[0]._ref.current.element);
    var rect = {
        top: firstSlotRect.top,
        left: firstSlotRect.left,
        right: firstSlotRect.right,
        width: firstSlotRect.width,
        height: 0
    };
    slots.forEach(function (slot) {
        if (!slot._ref.current) {
            return;
        }
        var height = getRect(slot._ref.current.element).height;
        if (height !== undefined) {
            if (!vertical && height >= rect.height) {
                rect.height = height;
            }
            else {
                rect.height += height;
            }
        }
    });
    return rect;
};
/**
 * @hidden
 */
export function toGroupResources(group, resources) {
    var result = [];
    if (!resources || !resources.length) {
        return result;
    }
    if (group && group.resources && group.resources.length) {
        var groups_1 = group.resources;
        var _loop_1 = function (idx) {
            var resource = resources.find(function (r) { return r.name === groups_1[idx]; });
            result.push(resource);
        };
        for (var idx = 0; idx < groups_1.length; idx++) {
            _loop_1(idx);
        }
    }
    return result;
}
/**
 * @hidden
 * TODO Move to date-math
 */
export function addUTCDays(date, offset) {
    var newDate = new Date(date.getTime());
    newDate.setUTCDate(newDate.getUTCDate() + offset);
    return newDate;
}
/**
 * @hidden
 * ResourceIterator:
 */
export var expandResources = function (resources, lastIndex) {
    if (lastIndex === void 0) { lastIndex = resources.length - 1; }
    var currentLastIndex = Math.max(0, lastIndex);
    var data = [];
    if (!(resources && resources.length)) {
        resources = [{}];
    }
    var lastData = (resources[currentLastIndex].data || []).map(function (d) { return (__assign(__assign({}, d), { text: d[resources[currentLastIndex].textField] })); }) || [];
    var length = lastData.length;
    var count = 1;
    for (var idx = 0; idx <= currentLastIndex; idx++) {
        count *= (resources[idx].data || []).length || 1;
    }
    for (var idx = 0; idx < count; idx++) {
        if (lastData[idx % length]) {
            data.push(lastData[idx % length]);
        }
    }
    return data;
};
/**
 * @hidden
 */
export var resourcesByIndex = function (index, taskResources, spans) {
    // TODO: introduce cache mechanism
    // if (!this.resourcesCache[index]) {
    var resources = taskResources;
    var result = [];
    var currentIndex = index;
    for (var idx = 0; idx < resources.length; idx++) {
        var data = resources[idx].data || [];
        var dataIdx = Math.floor(currentIndex / spans[idx]);
        result.push(data[dataIdx]);
        currentIndex -= dataIdx * spans[idx];
    }
    return result;
};
/** @hidden */
export var getRect = function (el) {
    if (!el) {
        return { top: 0, left: 0, width: 0, height: 0, right: 0 };
    }
    var top = el.offsetTop;
    var left = el.offsetLeft;
    var right = el.offsetParent ? el.offsetParent.offsetWidth - (el.offsetLeft + el.offsetWidth) : 0;
    var width = el.offsetWidth;
    var height = el.offsetHeight;
    return {
        top: top,
        left: left,
        right: right,
        width: width,
        height: height
    };
};
/** @hidden */
export var getPadding = function (el, horizontal) {
    if (horizontal === void 0) { horizontal = false; }
    return parseFloat(window.getComputedStyle(el)[horizontal ? 'paddingLeft' : 'paddingTop'] || '0')
        + parseFloat(window.getComputedStyle(el)[horizontal ? 'paddingRight' : 'paddingBottom'] || '0');
};
/** @hidden */
export var getBorders = function (el, horizontal) {
    if (horizontal === void 0) { horizontal = false; }
    return parseFloat(window.getComputedStyle(el)[horizontal ? 'borderLeftWidth' : 'borderTopWidth'] || '0')
        + parseFloat(window.getComputedStyle(el)[horizontal ? 'borderRightWidth' : 'borderBottomWidth'] || '0');
};
/** @hidden */
export var setRect = function (el, rect, minHeightInsteadOfHeight) {
    if (minHeightInsteadOfHeight === void 0) { minHeightInsteadOfHeight = false; }
    if (!el) {
        return;
    }
    if (rect.top !== undefined) {
        el.style.top = "".concat(rect.top, "px");
    }
    if (rect.left !== undefined) {
        el.style.left = "".concat(rect.left, "px");
    }
    if (rect.width !== undefined) {
        el.style.width = "".concat(rect.width, "px");
    }
    if (rect.height !== undefined && !minHeightInsteadOfHeight) {
        el.style.height = typeof rect.height === 'number' ? "".concat(rect.height, "px") : rect.height;
    }
    if (minHeightInsteadOfHeight) {
        el.style.minHeight = rect.height !== undefined && rect.height > 0 ? "".concat(rect.height, "px") : '';
    }
};
