var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { BaseView } from '../../components/BaseView';
import { MS_PER_DAY, firstDayInWeek, firstDayOfMonth, getDate, addDays, lastDayOfMonth, ZonedDate } from '@progress/kendo-date-math';
import { classNames } from '@progress/kendo-react-common';
import { VerticalResourceIterator } from '../common/VerticalResourceIterator';
import { HorizontalResourceIterator } from '../common/HorizontalResourceIterator';
import { mapItemsToSlots, mapSlotsToItems, toUTCDateTime, orderSort } from '../../utils';
import { monthViewTitle, messages } from '../../messages';
import { SchedulerEditSlot } from '../../slots/SchedulerEditSlot';
import { useInternationalization } from '@progress/kendo-react-intl';
import { DAYS_IN_WEEK_COUNT } from '../../constants';
import { toRanges } from '../../services/rangeService';
import { toSlots } from '../../services/slotsService';
import { toOccurrences } from '../../services/occurrenceService';
import { toItems } from '../../services/itemsService';
import { ShowMoreItemsButton } from '../../components/ShowMoreItemsButton';
import { SchedulerEditItem } from '../../items/SchedulerEditItem';
import { useSchedulerPropsContext, useSchedulerDataContext, useSchedulerDateContext, useSchedulerViewsContext, useSchedulerGroupsContext, useSchedulerOrientationContext, useSchedulerDateRangeContext, useSchedulerFieldsContext, useSchedulerActiveViewContext } from '../../context/SchedulerContext';
import { SchedulerResourceIteratorContext } from '../../context/SchedulerResourceIteratorContext';
import { DateHeaderCell } from '../../components/DateHeaderCell';
var DAY_FORMAT = { skeleton: 'dd' };
/**
 * Represents the KendoReact [MonthView]({% slug month_view_scheduler %}) Component.
 */
export var MonthView = function (props) {
    var _a = useSchedulerPropsContext(), group = _a.group, timezone = _a.timezone, propResources = _a.resources;
    var EditItem = props.editItem || SchedulerEditItem;
    var EditSlot = props.editSlot || SchedulerEditSlot;
    var data = useSchedulerDataContext()[0];
    var _b = useSchedulerDateContext(), setDate = _b[1];
    var _c = useSchedulerActiveViewContext(), setView = _c[1];
    var views = useSchedulerViewsContext();
    var groups = useSchedulerGroupsContext();
    var orientation = useSchedulerOrientationContext();
    var dateRange = useSchedulerDateRangeContext();
    var intl = useInternationalization();
    var fields = useSchedulerFieldsContext();
    var itemsPerSlot = props.itemsPerSlot || defaultProps.itemsPerSlot;
    var ranges = React.useMemo(function () { return toRanges(dateRange, { step: (MS_PER_DAY * DAYS_IN_WEEK_COUNT), timezone: timezone }); }, [dateRange.start.getTime(), dateRange.end.getTime(), timezone]);
    var slots = React.useMemo(function () { return toSlots(dateRange, { step: MS_PER_DAY }, { groups: groups, ranges: ranges }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        groups,
        ranges
    ]);
    var occurrences = React.useMemo(function () { return toOccurrences(data, { dateRange: dateRange, fields: fields, timezone: timezone }); }, [data, dateRange.start.getTime(), dateRange.end.getTime(), fields, timezone]);
    var items = React.useMemo(function () { return toItems(occurrences, { timezone: timezone }, { groups: groups, ranges: ranges }); }, [occurrences, timezone, groups, ranges]);
    var handleShowMoreItemsClick = React.useCallback(function (event) {
        var newView = views.find(function (vw) { return vw.props.name === 'day'; });
        if (!setView || !newView || !newView.props.name || !event.target.slot) {
            return;
        }
        setView(newView.props.name, event);
        setDate(event.target.slot.start, event);
    }, [
        setView,
        views
    ]);
    React.useMemo(function () { return mapItemsToSlots(items, slots, true); }, [items, slots]);
    React.useMemo(function () { return mapSlotsToItems(items, slots, true); }, [items, slots]);
    var head = (React.createElement(SchedulerResourceIteratorContext.Consumer, null, function (_a) {
        var groupIndex = _a.groupIndex;
        return (React.createElement("div", { className: "k-scheduler-row", key: groupIndex }, slots
            .filter(function (slot) { return slot.group.index === groupIndex && slot.range.index === 0; })
            .map(function (slot, slotIndex) { return (React.createElement(DateHeaderCell, { as: props.dateHeaderCell, key: slotIndex, "data-dayslot-index": slotIndex, date: ZonedDate.fromLocalDate(new Date(slot.zonedEnd.getTime() - ((slot.zonedEnd.getTime() - slot.zonedStart.getTime()) / 2)), timezone), start: slot.start, end: slot.end, format: { skeleton: 'EEEE' } })); })));
    }));
    var body = (React.createElement(SchedulerResourceIteratorContext.Consumer, null, function (_a) {
        var groupIndex = _a.groupIndex;
        return (ranges.map(function (_, rangeIndex) { return (React.createElement("div", { className: "k-scheduler-row", key: rangeIndex }, slots
            .filter(function (slot) { return slot.group.index === groupIndex && slot.range.index === rangeIndex; })
            .map(function (slot, slotIndex, filtered) { return (React.createElement(EditSlot, __assign({ slot: props.slot, viewSlot: props.viewSlot, key: slotIndex, form: props.form }, slot, { expandable: { offsetTop: 30, offsetBottom: (itemsPerSlot < slot.items.length) ? 15 : 0 }, onDataAction: props.onDataAction, col: orientation === 'horizontal'
                ? ((filtered.length * (groupIndex || 0)) + slotIndex)
                : slotIndex, row: orientation === 'horizontal'
                ? rangeIndex
                : ((ranges.length * (groupIndex || 0)) + rangeIndex), editable: props.editable }),
            React.createElement("span", { className: "k-link k-nav-day" }, intl.formatDate(new Date(slot.end.getTime() - ((slot.end.getTime() - slot.start.getTime()) / 2)), DAY_FORMAT)),
            (itemsPerSlot < slot.items.length) && (React.createElement(ShowMoreItemsButton, { slot: slot, onClick: handleShowMoreItemsClick })))); }))); }));
    }));
    return (React.createElement(BaseView, { props: props, slots: slots, ranges: ranges, className: classNames('k-scheduler-monthview', props.className) },
        React.createElement("div", { className: "k-scheduler-head" }, orientation === 'horizontal'
            ? React.createElement(HorizontalResourceIterator, { nested: true, resources: propResources, group: group }, head)
            : React.createElement(VerticalResourceIterator, { resources: propResources, group: group }, head)),
        React.createElement("div", { className: "k-scheduler-body" },
            orientation === 'horizontal'
                ? React.createElement(HorizontalResourceIterator, { resources: propResources, group: group }, body)
                : React.createElement(VerticalResourceIterator, { nested: true, resources: propResources, group: group }, body),
            items
                .filter(function (item) { return item.order === null || item.order < itemsPerSlot; })
                .sort(orderSort)
                .map(function (item) { return (React.createElement(EditItem, __assign({ item: props.item, viewItem: props.viewItem, form: props.form, key: item.isRecurring
                    ? "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index, ":").concat(item.originalStart)
                    : "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index) }, item, { onDataAction: props.onDataAction, style: { transform: 'translateY(30px)' }, vertical: false, editable: props.editable, ignoreIsAllDay: true }))); }))));
};
var monthViewDateRange = function (_a) {
    var intl = _a.intl, date = _a.date, timezone = _a.timezone;
    // The DateRange start from the first day of the week containing the first day of the month.
    // I know it sounds strange, but take a look and a wall-calendar!
    var firstDay = firstDayInWeek(firstDayOfMonth(getDate(date)), intl.firstDay());
    var lastDay = addDays(firstDayInWeek(lastDayOfMonth(getDate(date)), intl.firstDay()), DAYS_IN_WEEK_COUNT);
    var zonedStart = ZonedDate.fromUTCDate(toUTCDateTime(firstDay), timezone);
    var zonedEnd = ZonedDate.fromUTCDate(toUTCDateTime(lastDay), timezone);
    var start = new Date(zonedStart.getTime());
    var end = new Date(zonedEnd.getTime());
    return {
        start: start,
        end: end,
        zonedStart: zonedStart,
        zonedEnd: zonedEnd
    };
};
var defaultProps = {
    name: 'month',
    dateRange: monthViewDateRange,
    slotDuration: 24 * 60,
    slotDivision: 1,
    itemsPerSlot: 2,
    numberOfDays: 31,
    title: function (localization) { return localization.toLanguageString(monthViewTitle, messages[monthViewTitle]); },
    selectedDateFormat: '{0:Y}',
    selectedShortDateFormat: '{0:Y}'
};
var propTypes = {
    itemsPerSlot: PropTypes.number
};
MonthView.defaultProps = defaultProps;
MonthView.propTypes = propTypes;
MonthView.displayName = 'KendoReactSchedulerMonthView';
