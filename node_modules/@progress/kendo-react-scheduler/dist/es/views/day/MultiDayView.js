var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { Day, MS_PER_DAY, ZonedDate, getDate, addDays } from '@progress/kendo-date-math';
import { BaseView } from '../../components/BaseView';
import { HorizontalResourceIterator } from '../common/HorizontalResourceIterator';
import { DayViewGroupRowContent } from './DayViewGroupRowContent';
import { VerticalResourceIterator } from '../common/VerticalResourceIterator';
import { DayViewAllDayRowContent } from './DayViewAllDayRowContent';
import { DayViewRowContent } from './DayViewRowContent';
import { classNames } from '@progress/kendo-react-common';
import { mapItemsToSlots, mapSlotsToItems, isInTimeRange, toUTCDateTime, intersects, first, last, isInDaysRange } from '../../utils';
import { useInternationalization } from '@progress/kendo-react-intl';
import { MS_PER_MINUTE } from '../../constants';
import { toRanges, toItems, toSlots, toOccurrences } from '../../services/';
import { SchedulerEditSlot } from '../../slots/SchedulerEditSlot';
import { SchedulerEditItem } from '../../items/SchedulerEditItem';
import { useSchedulerPropsContext, useSchedulerDataContext, useSchedulerGroupsContext, useSchedulerOrientationContext, useSchedulerFieldsContext, useSchedulerDateRangeContext } from '../../context/SchedulerContext';
import { SchedulerResourceIteratorContext } from '../../context/SchedulerResourceIteratorContext';
import { CurrentTimeMarker } from '../../components/CurrentTimeMarket';
import { DateHeaderCell } from '../../components/DateHeaderCell';
var FIRST_INDEX = 0;
var GRID_OFFSET = 1;
var EMPTY_CELL = React.createElement("div", { className: "k-scheduler-cell k-side-cell" });
/**
 * @hidden
 */
export var MultiDayView = function (props) {
    var _a = useSchedulerPropsContext(), group = _a.group, timezone = _a.timezone, propResources = _a.resources;
    var intl = useInternationalization();
    var EditItem = props.editItem || SchedulerEditItem;
    var EditSlot = props.editSlot || SchedulerEditSlot;
    var showWorkHours = props.showWorkHours;
    var numberOfDays = props.numberOfDays || defaultProps.numberOfDays;
    var slotDivisions = props.slotDivisions || defaultProps.slotDivisions;
    var slotDuration = props.slotDuration || defaultProps.slotDuration;
    var workWeekStart = props.workWeekStart || defaultProps.workWeekStart;
    var workWeekEnd = props.workWeekEnd || defaultProps.workWeekEnd;
    var workDayStart = intl.parseDate(props.workDayStart || props.isWorkDayStart || defaultProps.isWorkDayStart);
    var workDayEnd = intl.parseDate(props.workDayEnd || props.isWorkDayEnd || defaultProps.isWorkDayEnd);
    var startTime = intl.parseDate(props.startTime || defaultProps.startTime);
    var endTime = intl.parseDate(props.endTime || defaultProps.endTime);
    var data = useSchedulerDataContext()[0];
    var groups = useSchedulerGroupsContext();
    var orientation = useSchedulerOrientationContext();
    var fields = useSchedulerFieldsContext();
    var dateRange = useSchedulerDateRangeContext();
    var viewStart = React.useMemo(function () { return showWorkHours
        ? workDayStart
        : startTime; }, [
        showWorkHours,
        workDayStart,
        startTime
    ]);
    var viewEnd = React.useMemo(function () { return showWorkHours
        ? workDayEnd
        : endTime; }, [
        showWorkHours,
        workDayEnd,
        endTime
    ]);
    var dayRanges = React.useMemo(function () { return toRanges(dateRange, { step: MS_PER_DAY * numberOfDays, timezone: timezone })
        .map(function (r) { return (__assign(__assign({}, r), { isAllDay: true })); }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        numberOfDays
    ]);
    var timeRanges = React.useMemo(function () { return toRanges(dateRange, { step: MS_PER_DAY, timezone: timezone })
        .map(function (r) { return (__assign(__assign({}, r), { isAllDay: false })); }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        timezone
    ]);
    var daySlots = React.useMemo(function () { return toSlots(dateRange, { step: MS_PER_DAY }, { groups: groups, ranges: dayRanges }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        timezone,
        dayRanges,
        groups
    ]);
    var timeSlots = React.useMemo(function () { return toSlots(dateRange, { step: (slotDuration * MS_PER_MINUTE) / slotDivisions }, { groups: groups, ranges: timeRanges })
        .filter(function (slot) { return viewEnd.getTime() === viewStart.getTime()
        || isInTimeRange(slot.zonedStart, viewStart, viewEnd); }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        slotDuration,
        slotDivisions,
        viewStart.getTime(),
        viewEnd.getTime(),
        groups,
        timeRanges
    ]);
    var occurrences = React.useMemo(function () { return toOccurrences(data, { dateRange: dateRange, fields: fields, timezone: timezone }); }, [data, dateRange.start.getTime(), dateRange.end.getTime(), fields, timezone]);
    var dayOccurrences = React.useMemo(function () { return occurrences.filter(function (o) { return o.isAllDay; }); }, [occurrences]);
    var timeOccurrences = React.useMemo(function () { return occurrences.filter(function (o) { return !o.isAllDay; }); }, [occurrences]);
    var dayItems = React.useMemo(function () { return toItems(dayOccurrences, { timezone: timezone }, { groups: groups, ranges: dayRanges }); }, [occurrences, timezone, groups, dayRanges]);
    var timeItems = React.useMemo(function () { return toItems(timeOccurrences, { timezone: timezone }, { groups: groups, ranges: timeRanges })
        .filter(function (item) { return viewStart.getTime() === viewEnd.getTime()
        || isInTimeRange(item.zonedStart, viewStart, viewEnd)
        || isInTimeRange(item.zonedEnd, viewStart, viewEnd)
        || isInTimeRange(new Date(item.zonedEnd.getTime() - ((item.zonedEnd.getTime() - item.zonedStart.getTime()) / 2)), viewStart, viewEnd); }); }, [occurrences, timezone, groups, timeRanges, viewStart.getTime(), viewEnd.getTime()]);
    React.useMemo(function () { return mapItemsToSlots(dayItems, daySlots, false); }, [dayItems, daySlots]);
    React.useMemo(function () { return mapSlotsToItems(dayItems, daySlots, false); }, [dayItems, daySlots]);
    React.useMemo(function () { return mapItemsToSlots(timeItems, timeSlots, false); }, [timeItems, timeSlots]);
    React.useMemo(function () { return mapSlotsToItems(timeItems, timeSlots, false); }, [timeItems, timeSlots]);
    var head = (React.createElement(SchedulerResourceIteratorContext.Consumer, null, function (_a) {
        var groupIndex = _a.groupIndex;
        return (React.createElement("div", { className: "k-scheduler-row", key: groupIndex }, timeRanges.map(function (range, rangeIndex) { return (React.createElement(DateHeaderCell, { as: props.dateHeaderCell, key: rangeIndex, date: ZonedDate.fromLocalDate(new Date(range.zonedEnd.getTime() - ((range.zonedEnd.getTime() - range.zonedStart.getTime()) / 2)), timezone), start: range.start, end: range.end, format: { skeleton: 'MEd' } })); })));
    }));
    var allDaySlots = (React.createElement(SchedulerResourceIteratorContext.Consumer, null, function (_a) {
        var groupIndex = _a.groupIndex;
        return (React.createElement("div", { key: groupIndex, className: "k-scheduler-row" }, dayRanges.map(function (_, rangeIndex) { return (daySlots
            .filter(function (s) { return s.group.index === groupIndex && s.range.index === rangeIndex; })
            .map(function (slot, slotIndex, filtered) { return (React.createElement(EditSlot, __assign({}, slot, { onDataAction: props.onDataAction, form: props.form, slot: props.slot, viewSlot: props.viewSlot, key: "".concat(slot.start.getTime(), ":").concat(slot.group.index), row: 0, col: orientation === 'horizontal' ? ((filtered.length * (groupIndex || 0)) + slotIndex) : slotIndex, isWorkDay: 0 <= ((slot.zonedStart.getDay() + (numberOfDays - workWeekStart)))
                && ((slot.zonedStart.getDay() + (numberOfDays - workWeekStart))
                    % numberOfDays)
                    <= ((workWeekEnd + (numberOfDays - workWeekStart))), expandable: true }))); })); })));
    }));
    var className = React.useMemo(function () { return classNames('k-scheduler-day-view', props.className); }, [props.className]);
    return (React.createElement(React.Fragment, null,
        React.createElement(BaseView, { id: props.id, props: props, style: props.style, className: className, ranges: __spreadArray(__spreadArray([], dayRanges, true), timeRanges, true), slots: __spreadArray(__spreadArray([], daySlots, true), timeSlots, true) },
            React.createElement("div", { className: "k-scheduler-head" }, orientation === 'horizontal'
                ? React.createElement(React.Fragment, null,
                    React.createElement(HorizontalResourceIterator, { nested: true, group: group, resources: propResources, rowContent: DayViewGroupRowContent, childRowContent: DayViewGroupRowContent }, head),
                    React.createElement(HorizontalResourceIterator, { group: group, resources: propResources, rowContent: DayViewAllDayRowContent, childRowContent: DayViewAllDayRowContent }, allDaySlots),
                    dayItems.map(function (item) { return (React.createElement(EditItem, __assign({ key: item.isRecurring
                            ? "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index, ":").concat(item.originalStart)
                            : "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index) }, item, { form: props.form, onDataAction: props.onDataAction, item: props.item, viewItem: props.viewItem, editable: props.editable, vertical: false }))); }))
                : React.createElement(VerticalResourceIterator, { group: group, resources: propResources, cellContent: EMPTY_CELL }, head)),
            React.createElement("div", { className: "k-scheduler-body" },
                orientation === 'horizontal'
                    ? (React.createElement(React.Fragment, null,
                        timeSlots
                            .filter(function (slot) { return slot.group.index === FIRST_INDEX && slot.range.index === FIRST_INDEX; })
                            .map(function (root, rootIndex) {
                            return (React.createElement(React.Fragment, { key: root.index },
                                React.createElement(HorizontalResourceIterator, { nested: false, group: group, resources: propResources, rowContent: DayViewRowContent, rowContentProps: {
                                        timeHeaderCell: props.timeHeaderCell,
                                        isMaster: (rootIndex % slotDivisions === 0),
                                        isLast: ((rootIndex + 1) % slotDivisions === 0),
                                        slot: root
                                    } },
                                    React.createElement(SchedulerResourceIteratorContext.Consumer, null, function (_a) {
                                        var groupIndex = _a.groupIndex;
                                        return (React.createElement("div", { className: classNames('k-scheduler-row', {
                                                'k-middle-row': !((rootIndex + 1) % slotDivisions === 0)
                                            }) }, timeRanges.map(function (_range, rangeIndex) { return (timeSlots
                                            .filter(function (s) { return s.index === root.index
                                            && s.range.index === rangeIndex
                                            && s.group.index === groupIndex; })
                                            .map(function (slot) { return (React.createElement(EditSlot, __assign({ key: "".concat(slot.start.getTime(), ":").concat(slot.group.index) }, slot, { onDataAction: props.onDataAction, slot: props.slot, viewSlot: props.viewSlot, form: props.form, row: rootIndex + GRID_OFFSET, col: (timeRanges.length * (groupIndex || 0)) + rangeIndex, isWorkHour: isInTimeRange(slot.zonedStart, workDayStart, workDayEnd), isWorkDay: isInDaysRange(slot.zonedEnd.getDay(), workWeekStart, workWeekEnd), editable: props.editable }))); })); })));
                                    }))));
                        }),
                        (props.currentTimeMarker
                            && intersects(first(timeRanges).start, last(timeRanges).end, new Date(), new Date(), true))
                            && (React.createElement(CurrentTimeMarker, null))))
                    : React.createElement(React.Fragment, null,
                        React.createElement(VerticalResourceIterator, { nested: true, group: group, resources: propResources },
                            React.createElement(SchedulerResourceIteratorContext.Consumer, null, function (_a) {
                                var groupIndex = _a.groupIndex;
                                return (React.createElement(React.Fragment, { key: groupIndex },
                                    React.createElement("div", { className: "k-scheduler-row" },
                                        React.createElement(DayViewAllDayRowContent, { groupIndex: groupIndex }, dayRanges.map(function (_, rangeIndex) {
                                            var groupOffset = timeSlots
                                                .filter(function (s) { return s.group.index === groupIndex && s.range.index === FIRST_INDEX; })
                                                .length;
                                            return (daySlots
                                                .filter(function (s) { return s.group.index === groupIndex && s.range.index === rangeIndex; })
                                                .map(function (slot, slotIndex) { return (React.createElement(EditSlot, __assign({ slot: props.slot, viewSlot: props.viewSlot, form: props.form }, slot, { onDataAction: props.onDataAction, key: "".concat(slot.start.getTime(), ":").concat(slot.group.index), className: 'k-scheduler-alldays-slot', row: ((groupOffset * (groupIndex || 0)))
                                                    + ((groupIndex || 0) * GRID_OFFSET), col: slotIndex, expandable: true }))); }));
                                        }))),
                                    timeSlots
                                        .filter(function (s) { return s.group.index === groupIndex && s.range.index === FIRST_INDEX; })
                                        .map(function (root, rootIndex, filtered) { return (React.createElement("div", { className: "k-scheduler-row", key: root.index },
                                        React.createElement(DayViewRowContent, { slot: root, isMaster: rootIndex % slotDivisions === 0, isLast: (rootIndex + 1) % slotDivisions === 0, timeHeaderCell: props.timeHeaderCell }, timeRanges.map(function (_, rangeIndex) { return (timeSlots
                                            .filter(function (s) { return s.index === root.index
                                            && s.group.index === groupIndex
                                            && s.range.index === rangeIndex; })
                                            .map(function (slot) { return (React.createElement(EditSlot, __assign({ slot: props.slot, viewSlot: props.viewSlot, form: props.form, onDataAction: props.onDataAction }, slot, { key: "".concat(slot.start.getTime(), ":").concat(slot.group.index), row: ((filtered.length * (groupIndex || 0)) + rootIndex)
                                                + ((groupIndex || 0) * GRID_OFFSET) + GRID_OFFSET, col: rangeIndex, editable: props.editable, isWorkHour: isInTimeRange(slot.zonedStart, workDayStart, workDayEnd), isWorkDay: 0 <= ((slot.zonedStart.getDay()
                                                + (numberOfDays - workWeekStart)))
                                                && ((slot.zonedStart.getDay()
                                                    + (numberOfDays - workWeekStart))
                                                    % numberOfDays)
                                                    <= ((workWeekEnd + (numberOfDays - workWeekStart))) }))); })); })))); }),
                                    ((props.currentTimeMarker
                                        && intersects(first(timeRanges).start, last(timeRanges).end, new Date(), new Date(), true)))
                                        && (React.createElement(CurrentTimeMarker, { groupIndex: groupIndex }))));
                            })),
                        dayItems.map(function (item) { return (React.createElement(EditItem, __assign({ key: item.isRecurring
                                ? "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index, ":").concat(item.originalStart)
                                : "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index) }, item, { onDataAction: props.onDataAction, viewItem: props.viewItem, item: props.item, form: props.form, editable: props.editable, vertical: false }))); })),
                timeItems.map(function (item) { return (React.createElement(EditItem, __assign({ key: item.isRecurring
                        ? "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index, ":").concat(item.originalStart)
                        : "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index) }, item, { format: 't', onDataAction: props.onDataAction, viewItem: props.viewItem, item: props.item, form: props.form, editable: props.editable, vertical: true }))); })))));
};
var multiDayViewDateRange = function (_a) {
    var date = _a.date, _b = _a.numberOfDays, numberOfDays = _b === void 0 ? 1 : _b, timezone = _a.timezone;
    var normalized = ZonedDate.fromLocalDate(date, timezone);
    var firstDay = getDate(normalized);
    var lastDay = addDays(firstDay, numberOfDays);
    var zonedStart = ZonedDate.fromUTCDate(toUTCDateTime(firstDay), timezone);
    var zonedEnd = ZonedDate.fromUTCDate(toUTCDateTime(lastDay), timezone);
    var start = new Date(zonedStart.getTime());
    var end = new Date(zonedEnd.getTime());
    return {
        start: start,
        end: end,
        zonedStart: zonedStart,
        zonedEnd: zonedEnd
    };
};
/** @hidden */
export var defaultProps = {
    name: 'multi-day',
    title: 'Multi Day',
    currentTimeMarker: true,
    dateRange: multiDayViewDateRange,
    selectedDateFormat: '{0:D} - {1:D}',
    selectedShortDateFormat: '{0:d} - {1:d}',
    numberOfDays: 1,
    startTime: '00:00',
    endTime: '23:59',
    isWorkDayStart: '08:00',
    isWorkDayEnd: '17:00',
    workWeekStart: Day.Monday,
    workWeekEnd: Day.Friday,
    step: 1,
    slotDivisions: 2,
    slotDuration: 60,
    showCurrentTime: true,
    defaultShowWorkHours: true
};
MultiDayView.propTypes = {
    currentTimeMarker: PropTypes.bool,
    name: PropTypes.string,
    numberOfDays: PropTypes.number,
    startTime: PropTypes.string,
    endTime: PropTypes.string,
    workDayStart: PropTypes.string,
    workDayEnd: PropTypes.string,
    workWeekStart: PropTypes.number,
    workWeekEnd: PropTypes.any,
    slotDivisions: PropTypes.number,
    slotDuration: PropTypes.number,
    showWorkHours: PropTypes.bool,
    selectedDateFormat: PropTypes.string,
    selectedShortDateFormat: PropTypes.string
};
MultiDayView.defaultProps = defaultProps;
MultiDayView.displayName = 'KendoReactSchedulerMultiDayView';
