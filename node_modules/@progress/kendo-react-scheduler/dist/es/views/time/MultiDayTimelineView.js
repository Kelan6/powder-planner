var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import { BaseView } from '../../components/BaseView';
import { useCellSync, useRowSync } from '../../hooks';
import { Day, MS_PER_DAY, MS_PER_MINUTE, getDate, ZonedDate, addDays } from '@progress/kendo-date-math';
import { HorizontalResourceIterator } from '../common/HorizontalResourceIterator';
import { TimelineViewRowContent } from './TimelineViewRowContent';
import { TimelineViewAllEventsRowContent } from './TimelineViewAllEventsRowContent';
import { VerticalResourceIterator } from '../common/VerticalResourceIterator';
import { mapItemsToSlots, mapSlotsToItems, isInTimeRange, toUTCDateTime, intersects, first, last, orderSort, isInDaysRange } from '../../utils';
import { classNames } from '@progress/kendo-react-common';
import { toRanges } from '../../services/rangeService';
import { toSlots } from '../../services/slotsService';
import { toOccurrences } from '../../services/occurrenceService';
import { toItems } from '../../services/itemsService';
import { SchedulerEditSlot } from '../../slots/SchedulerEditSlot';
import { BORDER_WIDTH } from '../../constants';
import { useInternationalization } from '@progress/kendo-react-intl';
import { SchedulerEditItem } from '../../items/SchedulerEditItem';
import { useSchedulerDataContext, useSchedulerPropsContext, useSchedulerGroupsContext, useSchedulerFieldsContext, useSchedulerDateRangeContext, useSchedulerOrientationContext } from '../../context/SchedulerContext';
import { SchedulerResourceIteratorContext } from '../../context/SchedulerResourceIteratorContext';
import { CurrentTimeMarker } from '../../components/CurrentTimeMarket';
import { DateHeaderCell } from '../../components/DateHeaderCell';
import { TimeHeaderCell } from '../../components/TimeHeaderCell';
var TIME_FORMAT = 't';
var FIRST_INDEX = 0;
/**
 * @hidden
 */
export var MultiDayTimelineView = function (props) {
    var _a = useSchedulerPropsContext(), group = _a.group, timezone = _a.timezone, propResources = _a.resources;
    var timeRef = React.useRef(null);
    var bodyRef = React.useRef(null);
    var EditItem = props.editItem || SchedulerEditItem;
    var EditSlot = props.editSlot || SchedulerEditSlot;
    var element = React.useRef(null);
    var data = useSchedulerDataContext()[0];
    var orientation = useSchedulerOrientationContext();
    var groups = useSchedulerGroupsContext();
    var dateRange = useSchedulerDateRangeContext();
    var fields = useSchedulerFieldsContext();
    var intl = useInternationalization();
    var showWorkHours = props.showWorkHours;
    var slotDivisions = props.slotDivisions || defaultProps.slotDivisions;
    var slotDuration = props.slotDuration || defaultProps.slotDuration;
    var workWeekStart = props.workWeekStart || defaultProps.workWeekStart;
    var workWeekEnd = props.workWeekEnd || defaultProps.workWeekEnd;
    var workDayStart = intl.parseDate(props.workDayStart || props.isWorkDayStart || defaultProps.isWorkDayStart);
    var workDayEnd = intl.parseDate(props.workDayEnd || props.isWorkDayEnd || defaultProps.isWorkDayEnd);
    var startTime = intl.parseDate(props.startTime || defaultProps.startTime);
    var endTime = intl.parseDate(props.endTime || defaultProps.endTime);
    var viewStart = React.useMemo(function () { return showWorkHours
        ? workDayStart
        : startTime; }, [
        showWorkHours,
        workDayStart,
        startTime
    ]);
    var viewEnd = React.useMemo(function () { return showWorkHours
        ? workDayEnd
        : endTime; }, [
        showWorkHours,
        workDayEnd,
        endTime
    ]);
    var ranges = React.useMemo(function () { return toRanges(dateRange, { step: MS_PER_DAY, timezone: timezone }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        timezone
    ]);
    var slots = React.useMemo(function () { return toSlots(dateRange, { step: slotDuration / slotDivisions * MS_PER_MINUTE }, { groups: groups, ranges: ranges })
        .filter(function (slot) { return isInTimeRange(slot.zonedStart, viewStart, viewEnd) || viewStart.getTime() === viewEnd.getTime(); }); }, [
        groups,
        ranges,
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        timezone,
        slotDuration,
        slotDivisions,
        viewStart.getTime(),
        viewEnd.getTime()
    ]);
    var occurrences = React.useMemo(function () { return toOccurrences(data, { dateRange: dateRange, fields: fields, timezone: timezone }); }, [data, dateRange.start.getTime(), dateRange.end.getTime(), fields, timezone]);
    var items = React.useMemo(function () { return toItems(occurrences, { timezone: timezone }, { groups: groups, ranges: ranges })
        .filter(function (item) { return viewStart.getTime() === viewEnd.getTime()
        || isInTimeRange(item.zonedStart, viewStart, viewEnd)
        || isInTimeRange(item.zonedEnd, viewStart, viewEnd)
        || isInTimeRange(new Date(item.zonedEnd.getTime() - ((item.zonedEnd.getTime() - item.zonedStart.getTime()) / 2)), viewStart, viewEnd); }); }, [occurrences, timezone, groups, ranges, viewStart.getTime(), viewEnd.getTime()]);
    React.useMemo(function () { return mapItemsToSlots(items, slots, true); }, [items, slots]);
    React.useMemo(function () { return mapSlotsToItems(items, slots, true); }, [items, slots]);
    var width = (orientation === 'horizontal' ? slots.length : slots.length / groups.length)
        * ((props.columnWidth || defaultProps.columnWidth) + BORDER_WIDTH);
    var head = (React.createElement(SchedulerResourceIteratorContext.Consumer, null, function () { return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: "k-scheduler-row" }, ranges.map(function (range, rangeIndex) { return (React.createElement(DateHeaderCell, { as: props.dateHeaderCell, key: rangeIndex, date: range.zonedStart, start: range.start, end: range.end, format: 'm' })); })),
        React.createElement("div", { className: "k-scheduler-row", ref: timeRef }, ranges.map(function (_, rangeIndex) {
            return slots
                .filter(function (s) { return (s.group.index === FIRST_INDEX && s.range.index === rangeIndex); })
                .map(function (slot) { return (slot.zonedStart.getMinutes() % slotDuration === 0
                ? (React.createElement(TimeHeaderCell, { key: slot.index, as: props.timeHeaderCell, format: TIME_FORMAT, date: slot.zonedStart, start: slot.zonedStart, end: slot.zonedEnd })) : null); });
        })))); }));
    var body = (React.createElement(SchedulerResourceIteratorContext.Consumer, null, function (_a) {
        var groupIndex = _a.groupIndex;
        return (React.createElement("div", { className: "k-scheduler-row" }, ranges.map(function (_, rangeIndex) {
            return (slots
                .filter(function (s) { return s.group.index === groupIndex && s.range.index === rangeIndex; })
                .map(function (slot, slotIndex, filtered) { return (React.createElement(EditSlot, __assign({ key: "".concat(slot.start.getTime(), ":").concat(slot.group.index), slot: props.slot, viewSlot: props.viewSlot }, slot, { form: props.form, onDataAction: props.onDataAction, isWorkHour: isInTimeRange(slot.zonedStart, workDayStart, workDayEnd), isWorkDay: isInDaysRange(slot.zonedEnd.getDay(), workWeekStart, workWeekEnd), col: orientation === 'horizontal'
                    ? (((rangeIndex * filtered.length) + slotIndex)
                        + ((filtered.length * ranges.length) * (groupIndex || 0)))
                    : ((rangeIndex * filtered.length) + slotIndex), row: orientation === 'horizontal'
                    ? 0
                    : (groupIndex || 0), expandable: true, editable: props.editable }))); }));
        })));
    }));
    var className = React.useMemo(function () { return classNames('k-scheduler-timeline-view', props.className); }, [props.className]);
    useCellSync({
        element: element,
        selector: '.k-resource-cell',
        attribute: 'data-depth-index',
        explicitDepth: true
    });
    useRowSync({
        element: element,
        selector: '.k-resource-row',
        horizontalAttribute: 'data-depth-index',
        verticalAttribute: 'data-resource-index',
        applyTo: '.k-resource-cell'
    });
    return (React.createElement(React.Fragment, null,
        React.createElement(BaseView, { ref: element, id: props.id, style: (__assign({}, props.style)), className: className, props: props, slots: slots, ranges: ranges },
            React.createElement("div", { className: "k-scheduler-head", style: { width: width } }, orientation === 'horizontal'
                ? React.createElement(HorizontalResourceIterator, { nested: true, group: group, resources: propResources, rowContent: TimelineViewRowContent }, head)
                : React.createElement(VerticalResourceIterator, { wrapGroup: true, group: group, resources: propResources }, head)),
            React.createElement("div", { className: "k-scheduler-body", style: { width: width }, ref: bodyRef },
                orientation === 'horizontal'
                    ? React.createElement(HorizontalResourceIterator, { group: group, resources: propResources, rowContent: TimelineViewAllEventsRowContent },
                        body,
                        React.createElement(SchedulerResourceIteratorContext.Consumer, null, function (_a) {
                            var groupIndex = _a.groupIndex;
                            return ((props.currentTimeMarker
                                && intersects(first(ranges).start, last(ranges).end, new Date(), new Date(), true))
                                && (React.createElement(CurrentTimeMarker, { groupIndex: groupIndex, attachArrow: timeRef, vertical: true })));
                        }))
                    : React.createElement(VerticalResourceIterator, { nested: true, wrapGroup: true, group: group, resources: propResources }, body),
                (orientation === 'vertical'
                    && props.currentTimeMarker
                    && intersects(first(ranges).start, last(ranges).end, new Date(), new Date(), true))
                    && (React.createElement(CurrentTimeMarker, { attachArrow: timeRef, vertical: true })),
                items
                    .sort(orderSort)
                    .map(function (item) { return (React.createElement(EditItem, __assign({ key: item.isRecurring
                        ? "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index, ":").concat(item.originalStart)
                        : "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index) }, item, { format: 't', form: props.form, onDataAction: props.onDataAction, item: props.item, viewItem: props.viewItem, editable: props.editable, ignoreIsAllDay: true, vertical: false }))); })))));
};
var multiDayTimelineDateRange = function (_a) {
    var date = _a.date, _b = _a.numberOfDays, numberOfDays = _b === void 0 ? 1 : _b, timezone = _a.timezone;
    var normalized = ZonedDate.fromLocalDate(date, timezone);
    var firstDay = getDate(normalized);
    var lastDay = addDays(firstDay, numberOfDays);
    var zonedStart = ZonedDate.fromUTCDate(toUTCDateTime(firstDay), timezone);
    var zonedEnd = ZonedDate.fromUTCDate(toUTCDateTime(lastDay), timezone);
    var start = new Date(zonedStart.getTime());
    var end = new Date(zonedEnd.getTime());
    return {
        start: start,
        end: end,
        zonedStart: zonedStart,
        zonedEnd: zonedEnd
    };
};
/** @hidden */
export var defaultProps = {
    name: 'multi-day-timeline',
    title: 'Multi Day Timeline',
    currentTimeMarker: true,
    dateRange: multiDayTimelineDateRange,
    selectedDateFormat: '{0:D} - {1:D}',
    selectedShortDateFormat: '{0:d} - {1:d}',
    step: 1,
    numberOfDays: 1,
    startTime: '00:00',
    endTime: '00:00',
    isWorkDayStart: '8:00',
    isWorkDayEnd: '17:00',
    workWeekStart: Day.Monday,
    workWeekEnd: Day.Friday,
    slotDivisions: 2,
    slotDuration: 60,
    // showCurrentTime: true // TODO: Phase 2
    defaultShowWorkHours: true,
    columnWidth: 100
};
MultiDayTimelineView.defaultProps = defaultProps;
