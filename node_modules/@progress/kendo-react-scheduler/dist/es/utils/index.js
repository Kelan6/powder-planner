var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { getDate, cloneDate } from '@progress/kendo-date-math';
import { toGroupResources, toFlatGroupResources } from '../views/common/utils';
import { getter, setter, clone } from '@progress/kendo-react-common';
import { 
// OCCURRENCE_ID,
DEFAULT_ID } from '../constants';
import { orderBy } from '@progress/kendo-data-query';
/** @hidden */
export var first = function (arr) { return arr[0]; };
/** @hidden */
export var last = function (arr) { return arr[arr.length - 1]; };
/** @hidden */
export var isMultiDay = function (item) {
    var result = (item.end.getTime() - item.start.getTime()) > new Date(0).setHours(24);
    return result;
};
/** @hidden */
export var isGroupped = function (resources) {
    var set = new Set();
    resources.forEach(function (resource) {
        set.add(resource.field);
    });
    return set.size === resources.length;
};
/**
 * @hidden
 */
export function formatEventTime(intl, start, end, isAllDay) {
    var startTimeFormat = { skeleton: 'yMMMMEEEEdhm' };
    var startDateFormat = { skeleton: 'yMMMMEEEEd' };
    var endFormat = 't';
    return isAllDay ?
        "".concat(intl.formatDate(start, startDateFormat)) :
        "".concat(intl.formatDate(start, startTimeFormat), "\u2013").concat(intl.formatDate(end, endFormat));
}
/**
 * @hidden
 * TODO Move to date-math
 */
export var addUTCDays = function (date, offset) {
    var newDate = new Date(date.getTime());
    newDate.setUTCDate(newDate.getUTCDate() + offset);
    return newDate;
};
/** @hidden */
export function dateWithTime(target, time) {
    return new Date(target.getFullYear(), target.getMonth(), target.getDate(), time.getHours(), time.getMinutes());
}
/**
 * @hidden
 */
export var getToday = function () { return getDate(new Date()); };
// Introduce max depth doe to Maximum call stack size exceeded when react <body />
// The element.closest() approach is not available due to browser support issues.
/** @hidden */
export var slotDive = function (x, y, maxDepth, level) {
    if (level === void 0) { level = 0; }
    if (level === maxDepth) {
        return null;
    }
    var result = null;
    var element = document.elementFromPoint(x, y);
    if (!element) {
        return result;
    }
    var isSlot = element.getAttribute('data-slot') === 'true';
    if (isSlot) {
        return element;
    }
    else {
        var oldPointerEvents = element.style.pointerEvents;
        element.style.pointerEvents = 'none';
        result = slotDive(x, y, maxDepth, level + 1);
        element.style.pointerEvents = oldPointerEvents;
    }
    return result;
};
/**
 * @hidden
 */
export var getField = function (obj, field) { return getter(field)(obj); };
/**
 * @hidden
 */
export var setField = function (obj, field, value) {
    if (!field) {
        return;
    }
    return setter(field)(obj, value);
};
/**
 * @hidden
 */
export function assignField(target, source, field) {
    setField(target, field, getField(source, field));
}
/**
 * @hidden
 */
export function assignFields(target, source) {
    var fields = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        fields[_i - 2] = arguments[_i];
    }
    for (var idx = 0; idx < fields.length; idx++) {
        assignField(target, source, fields[idx]);
    }
}
/**
 * @hidden
 */
export var isPresent = function (value) { return value !== null && value !== undefined; };
/**
 * @hidden
 */
export var isRecurringMaster = function (event) { return event.recurrenceRule && !isPresent(event.recurrenceId); };
//  TODO: move to date-math
/** @hidden */
export function toUTCDate(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate()));
}
// TODO: move to date-math
/** @hidden */
export function getUTCDate(utcDate) {
    return new Date(Date.UTC(utcDate.getUTCFullYear(), utcDate.getUTCMonth(), utcDate.getUTCDate()));
}
// TODO: move to date-math
/** @hidden */
export function toUTCDateTime(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));
}
/** @hidden */
export function toInvariantTime(date) {
    var staticDate = new Date(1980, 1, 1, 0, 0, 0);
    if (date) {
        staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
    }
    return staticDate;
}
/** @hidden */
export function isRecurringException(event) {
    return event && isPresent(event.recurrenceId) && !event.recurrenceRule;
}
/**
 * @hidden
 */
export var isRecurring = function (event, fields) {
    var recurrenceId = getter(fields.recurrenceId || 'recurrenceId')(event);
    var recurrenceRule = getter(fields.recurrenceRule || 'recurrenceRule')(event);
    return !!(recurrenceRule || recurrenceId);
};
/**
 * @hidden
 */
export var groupResources = function (group, resources) {
    var result = [];
    if (group && group.resources && group.resources.length) {
        var groups_1 = group.resources;
        var _loop_1 = function (idx) {
            var resource = resources.find(function (r) { return r.name === groups_1[idx]; });
            result.push(resource);
        };
        for (var idx = 0; idx < groups_1.length; idx++) {
            _loop_1(idx);
        }
    }
    return result;
};
/**
 * @hidden
 */
export var findMaster = function (event, fields, data) {
    var headId = isMaster(event, fields) ? getField(event, fields.id) : getField(event, fields.recurrenceId);
    return data.find(function (currentEvent) { return getField(currentEvent, fields.id) === headId; });
};
/**
 * @hidden
 */
export var isMaster = function (event, fields) {
    var id = getField(event, fields.id);
    var recurrenceId = getField(event, fields.recurrenceId);
    var recurrenceRule = getField(event, fields.recurrenceRule);
    return !!(id && recurrenceRule && (recurrenceId === undefined || recurrenceId === null));
};
/**
 * @hidden
 */
export var buildException = function (event, fields, data) {
    var headEvent = findMaster(event, fields, data);
    var copy = clone(event);
    assignField(copy, headEvent, fields.id);
    if (fields.id !== undefined) {
        setField(copy, fields.id, DEFAULT_ID);
    }
    if (fields.recurrenceRule !== undefined) {
        setField(copy, fields.recurrenceRule, undefined);
    }
    if (fields.recurrenceId !== undefined) {
        setField(copy, fields.recurrenceId, getField(headEvent, fields.id));
    }
    return copy;
};
/**
 * @hidden
 */
export var isException = function (event, fields) {
    return isPresent(getField(event, fields.recurrenceId)) && !getField(event, fields.recurrenceRule);
};
var maxDate = function (x, y) { return Math.max(x.getTime(), y.getTime()); };
var minDate = function (x, y) { return Math.min(x.getTime(), y.getTime()); };
/** @hidden */
export var intersects = function (startTime, endTime, periodStart, periodEnd, inclusive) {
    if (inclusive === void 0) { inclusive = false; }
    return inclusive
        ? maxDate(endTime, periodEnd) - minDate(startTime, periodStart) <=
            (endTime.getTime() - startTime.getTime()) + (periodEnd.getTime() - periodStart.getTime())
        : maxDate(endTime, periodEnd) - minDate(startTime, periodStart) <
            (endTime.getTime() - startTime.getTime()) + (periodEnd.getTime() - periodStart.getTime());
};
/** @hidden */
export var roundAllDayEnd = function (_a) {
    var start = _a.start, end = _a.end;
    var startDate = start.stripTime();
    var endDate = end.stripTime();
    return endDate.getTime() !== end.getTime() || startDate.getTime() === endDate.getTime() ? endDate.addDays(1) : endDate;
};
/**
 * @hidden
 */
export var defaultModelFields = {
    id: 'id',
    start: 'start',
    startTimezone: 'startTimezone',
    originalStart: 'originalStart',
    end: 'end',
    endTimezone: 'endTimezone',
    isAllDay: 'isAllDay',
    title: 'title',
    description: 'description',
    recurrenceRule: 'recurrenceRule',
    recurrenceId: 'recurrenceId',
    recurrenceExceptions: 'recurrenceExceptions'
};
/** @hidden */
export var getModelFields = function (modelFields) {
    return { fields: __assign(__assign({}, defaultModelFields), modelFields) };
};
/** @hidden */
export var isInTimeRange = function (date, min, max) {
    return ((min.getHours() < date.getHours()) || (min.getHours() === date.getHours() && min.getMinutes() <= date.getMinutes()))
        && ((date.getHours() < max.getHours()) || (max.getHours() === date.getHours() && date.getMinutes() < max.getMinutes()));
};
/** @hidden */
export var isInDaysRange = function (date, min, max) {
    return min < max
        ? (min <= date && date <= max)
        : (date <= max || min <= date);
};
// /** @hidden */
// export const generateGroups = (
//     groupIndex: string | null,
//     nextGroupIndex: string | null,
//     groups: any[],
//     group: SchedulerGroup | undefined,
//     resources: SchedulerResource[] = []
// ) => {
//     if (!groupIndex || !nextGroupIndex) { return []; }
//     const groupedResources = toGroupResources(group, resources);
//     const flat = toFlatGroupResources(groupedResources);
//     return groups.map(g => g.index === Number(groupIndex)
//         ? { index: Number((nextGroupIndex)), resources: flat[Number(nextGroupIndex)] }
//         : g);
// };
/** @hidden */
export var toSchedulerGroups = function (group, resources) {
    var groupedResources = toGroupResources(group, resources);
    var flat = toFlatGroupResources(groupedResources);
    if (flat.length === 1) {
        return [{
                index: 0,
                // resources: []
                resources: (resources || [])
                    .reduce(function (all, res) { return __spreadArray(__spreadArray([], all, true), res.data
                    .map(function (item) { return (__assign(__assign({}, item), { field: res.field, valueField: res.valueField, colorField: res.colorField, multiple: res.multiple })); }), true); }, [])
            }];
    }
    else {
        return flat.map(function (res, index) { return ({
            index: index,
            resources: res
        }); });
    }
};
/** @hidden */
export var toSchedulerResources = function (resources) {
    if (resources === void 0) { resources = []; }
    return resources.reduce(function (all, res) { return __spreadArray(__spreadArray([], all, true), res.data.map(function (item) { return (__assign(__assign({}, item), { field: res.field, valueField: res.valueField, colorField: res.colorField, multiple: res.multiple })); }), true); }, []);
};
/** @hidden */
export var generateResourceFields = function (groups, defaultFields) {
    if (!groups || !groups.length) {
        return defaultFields;
    }
    var result = {};
    groups.forEach(function (group) {
        group.resources.forEach(function (resource) {
            if (result[resource.field] === undefined) {
                result[resource.field] = resource[resource.valueField];
            }
        });
    });
    return result;
};
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
export var isBlank = function (value) { return value === null || value === undefined; };
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
export var isNullOrEmptyString = function (value) { return isBlank(value) || (value.trim && value.trim().length === 0); };
/**
 * @hidden
 */
export var setTime = function (origin, candidate) {
    var date = cloneDate(origin);
    date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());
    return date;
};
function getDataIdx(value, resource) {
    var data = resource.data;
    for (var dataIdx = 0; dataIdx < data.length; dataIdx++) {
        if (getField(data[dataIdx], resource.valueField) === value) {
            return dataIdx;
        }
    }
    return 0;
}
/** @hidden */
export var extractGroups = function (dataItem, fields, group, resources) {
    var groupedResources = toGroupResources(group, resources);
    var flat = toFlatGroupResources(groupedResources);
    var flatGroupsReducer = function (acc, items, index) {
        var match = true;
        items.forEach(function (item) {
            var expected = item[item.valueField];
            var actual = dataItem[fields[item.field] || item.field];
            if (Array.isArray(actual)) {
                match = match && actual.indexOf(expected) >= 0;
            }
            else {
                match = match && actual === expected;
            }
        });
        if (match) {
            return __spreadArray(__spreadArray([], acc, true), [{ index: index, resources: items }], false);
        }
        else {
            return acc;
        }
    };
    return flat.reduce(flatGroupsReducer, []);
};
var findLeafResource = function (level) {
    if (level === void 0) { level = 0; }
    return findLeafResource(level + 1);
};
/** @hidden */
export var extractResourceFields = function (dataItem, fields, resources) {
    var result = {};
    if (!resources || !resources.length) {
        return result;
    }
    resources.forEach(function (resource) {
        var match = resource.data.find(function (item) { return item.value === dataItem[fields[resource.field] || resource.field]; });
        if (match) {
            result[resource.field] = match.value;
        }
    });
    return result;
};
/** @hidden */
export var extractResources = function (dataItem, fields, resources) {
    if (resources === void 0) { resources = []; }
    var resourceIndex = 0;
    var itemResources = [];
    for (var resourceIdx = 0; resourceIdx < resources.length; resourceIdx++) {
        var resource = resources[resourceIdx];
        var values = getField(dataItem, fields[resource.field] || resource.field);
        if (!Array.isArray(values)) {
            values = [values];
        }
        for (var valueIndex = 0; valueIndex < values.length; valueIndex++) {
            if (values[valueIndex] !== undefined) {
                var dataIdx = getDataIdx(values[valueIndex], resource);
                var data = resource.data[dataIdx];
                var itemResource = {
                    text: getField(data, resource.textField),
                    color: getField(data, resource.colorField),
                    value: getField(data, resource.valueField)
                };
                itemResources.push(__assign(__assign({}, itemResource), { index: resourceIndex }));
            }
            resourceIndex++;
        }
    }
    return itemResources;
};
// Change from JSON.stringify to recursive compare! use clone
/** @hidden */
export var shallowCompare = function (x, y) { return JSON.stringify(x) === JSON.stringify(y); };
/** @hidden */
export var findMissing = function (orderNumbers) {
    var result = 0;
    var numbers = orderNumbers.slice();
    // Array.find is also O(n)
    numbers.sort(function (a, b) { return a - b; }).forEach(function (_, index) {
        if (numbers[index] === index) {
            result = index + 1;
        }
    });
    return result;
};
/** @hidden */
export var calculateOrder = function (current, items, slots, ignoreIsAllDay) {
    if (ignoreIsAllDay === void 0) { ignoreIsAllDay = false; }
    var result;
    slots.forEach(function (slot) {
        var orderNumbers = [];
        var sorted = items.sort(function (a, b) { return a.props.start.getTime() - b.props.start.getTime(); });
        sorted.forEach(function (item) {
            var fit = (ignoreIsAllDay || (item.props.isAllDay === slot.current.props.isAllDay))
                && item.props.range.index === slot.current.props.range.index
                && item.props.group.index === slot.current.props.group.index
                && intersects(item.props.start, item.props.end, slot.current.props.start, slot.current.props.end);
            if (fit) {
                var order = findMissing(orderNumbers);
                if (item === current && result === undefined) {
                    result = order;
                }
                orderNumbers.splice(order, 0, order);
            }
        });
    });
    return result;
};
// TODO: REVISIT
/** @hidden */
export var mapSlotsToItems = function (items, slots, ignoreIsAllDay) {
    if (ignoreIsAllDay === void 0) { ignoreIsAllDay = false; }
    // Clear
    slots.forEach(function (slot) { return slot.items.splice(0, slot.items.length); });
    // Populate
    slots.forEach(function (slot) {
        var orderNumbers = [];
        items.forEach(function (item) {
            var fit = (ignoreIsAllDay || (item.isAllDay === slot.isAllDay))
                && item.range.index === slot.range.index
                && item.group.index === slot.group.index
                && intersects(item.start, item.end, slot.start, slot.end);
            if (fit) {
                var order = findMissing(orderNumbers);
                if (item.order === null || item.order === undefined || item.order < order) {
                    item.order = order;
                }
                orderNumbers.splice(item.order, 0, item.order);
                slot.items.push(item);
            }
        });
    });
};
// TODO: REVISIT
/** @hidden */
export var mapItemsToSlots = function (items, slots, ignoreIsAllDay) {
    if (ignoreIsAllDay === void 0) { ignoreIsAllDay = false; }
    // Clear
    items.forEach(function (item) { return item.slots.splice(0, item.slots.length); });
    // Populate
    items.forEach(function (item) {
        slots.forEach(function (slot) {
            var fit = (ignoreIsAllDay || (item.isAllDay === slot.isAllDay))
                && item.range.index === slot.range.index
                && item.group.index === slot.group.index
                && intersects(item.start, item.end, slot.start, slot.end);
            if (fit) {
                item.slots.push(slot);
            }
        });
    });
};
/** @hidden */
export var noop = function () {
    var _args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        _args[_i] = arguments[_i];
    }
};
/** @hidden */
export var findFirstItem = function (current) {
    var next = current.props.items.find(function (i) { return i.order === 0; }) || current.props.items[0];
    return next && next._ref.current;
};
/** @hidden */
export var findNextItem = function (ref, all, ignoreIsAllDay, backwards) {
    if (ignoreIsAllDay === void 0) { ignoreIsAllDay = false; }
    if (backwards === void 0) { backwards = false; }
    var current = ref.current;
    if (!current || !all) {
        return null;
    }
    var filtered = all.filter(function (i) { return i.current !== null && i.current.element !== null; });
    var sorted = orderBy(filtered, [
        { field: 'current.props.group.index', dir: 'asc' },
        { field: 'current.props.range.index', dir: 'asc' },
        (ignoreIsAllDay ? { field: '' } : { field: 'current.props.isAllDay', dir: 'desc' }),
        { field: 'current.props.start', dir: 'asc' }
    ]);
    var currentIndex = sorted
        .findIndex(function (i) { return i.current !== null && Boolean(i.current.props.uid === current.props.uid
        && ((i.current.props.occurrenceId === undefined) || i.current.props.occurrenceId === current.props.occurrenceId)
        && (i.current.props.group.index === current.props.group.index)
        && (i.current.props.range.index === current.props.range.index)
        && (ignoreIsAllDay || i.current.props.isAllDay === current.props.isAllDay)); });
    var next = sorted[currentIndex + (backwards ? -1 : 1)];
    return next;
};
/**
 * @hidden
 */
export var orderSort = function (a, b) {
    return (a.order || 0) - (b.order || 0);
};
