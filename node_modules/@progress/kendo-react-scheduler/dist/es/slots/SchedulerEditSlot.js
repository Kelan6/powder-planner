var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import { Keys } from '@progress/kendo-react-common';
import { DATA_ACTION } from '../Scheduler';
import { setField, getField, findFirstItem, isGroupped } from '../utils';
import { SchedulerForm } from '../components/SchedulerForm';
import { SchedulerViewSlot } from './SchedulerViewSlot';
import { SLOTS_FOCUS_ACTION, useEditable } from '../hooks';
import { useControlledState } from '../hooks/useControlledState';
import { useSchedulerFieldsContext } from '../context/SchedulerContext';
import { useSchedulerViewSlotsContext, useSchedulerViewSelectedSlotsContext, useSchedulerViewFocusedSlotsContext, useSchedulerViewItemsContext } from '../context';
import { SchedulerEditSlotContext } from '../context/SchedulerEditSlotContext';
import { SLOTS_SELECT_ACTION } from '../hooks/use-slots-selection';
/* eslint-disable max-len */
/**
 * Represents the default `editSlot` component rendered by the [KendoReact Scheduler component]({% slug overview_scheduler %}).
 *
 * This is a composite component of the [`SchedulerViewSlot`]({% slug api_scheduler_schedulerviewslot %}), extending it to allow creating an item inside the slot.
 */
// tslint:enable:max-line-length
export var SchedulerEditSlot = React.forwardRef(function (props, ref) {
    var _ref = props._ref, onDataAction = props.onDataAction, propViewSlot = props.viewSlot, propForm = props.form, propFormItem = props.formItem, onFormItemChange = props.onFormItemChange, viewSlotProps = __rest(props, ["_ref", "onDataAction", "viewSlot", "form", "formItem", "onFormItemChange"]);
    var _a = React.useState(props.tabIndex), tabIndex = _a[0], setTabIndex = _a[1];
    var slot = React.useRef(null);
    var editableSlot = React.useRef(null);
    React.useImperativeHandle(editableSlot, function () { return ({ props: props }); });
    React.useImperativeHandle(ref, function () { return editableSlot.current; });
    React.useImperativeHandle(_ref, function () { return slot.current; });
    var editable = useEditable(props.editable);
    var fields = useSchedulerFieldsContext();
    var slots = useSchedulerViewSlotsContext()[0];
    var items = useSchedulerViewItemsContext()[0];
    var _b = useSchedulerViewSelectedSlotsContext(), selectedSlots = _b[0], dispatchSlotsSelection = _b[1];
    var _c = useSchedulerViewFocusedSlotsContext(), dispatchFocusedSlots = _c[1];
    var Form = propForm || defaultProps.form;
    var ViewSlot = propViewSlot || defaultProps.viewSlot;
    var _d = useControlledState(null, propFormItem, props.onFormItemChange), formItem = _d[0], setFormItem = _d[1];
    var selected = selectedSlots.some(function (s) { return Boolean(s.current
        && s.current.props.start.getTime() === props.start.getTime()
        && s.current.props.end.getTime() === props.end.getTime()
        && s.current.props.index === props.index
        && s.current.props.group.index === props.group.index
        && s.current.props.range.index === props.range.index
        && s.current.props.isAllDay === props.isAllDay); });
    var createDataItemFromSlot = React.useCallback(function () {
        var dataItem = {};
        setField(dataItem, fields.start, new Date(props.start.getTime()));
        setField(dataItem, fields.end, new Date(props.end.getTime()));
        setField(dataItem, fields.isAllDay, props.isAllDay);
        if (props.group.resources.length) {
            for (var idx = 0; idx < props.group.resources.length; idx++) {
                var resource = props.group.resources[idx];
                if (isGroupped(props.group.resources)) {
                    var value = getField(props.group.resources[idx], resource.valueField);
                    setField(dataItem, resource.field, resource.multiple ? [value] : value);
                }
                else {
                    setField(dataItem, resource.field, resource.multiple ? [] : undefined);
                }
            }
        }
        return dataItem;
    }, [
        fields.start,
        fields.end,
        fields.isAllDay,
        props.start,
        props.end,
        props.isAllDay,
        props.group.resources
    ]);
    // Handlers
    // Focus
    var handleFocus = React.useCallback(function (event) {
        if (editable.select) {
            dispatchSlotsSelection({
                type: SLOTS_SELECT_ACTION.select,
                slot: slot
            }, event.syntheticEvent);
        }
        if (props.onFocus) {
            props.onFocus.call(undefined, event);
        }
    }, [
        dispatchSlotsSelection,
        editable.select,
        props.onFocus
    ]);
    // Mouse
    var handleDoubleClick = React.useCallback(function (event) {
        if (editable.add) {
            var dataItem = createDataItemFromSlot();
            setFormItem(dataItem, event);
        }
        if (props.onDoubleClick) {
            props.onDoubleClick.call(undefined, event);
        }
    }, [
        createDataItemFromSlot,
        editable.add,
        props.onDoubleClick,
        setFormItem
    ]);
    var handleKeyDown = React.useCallback(function (event) {
        var nextItem;
        switch (event.syntheticEvent.keyCode) {
            case Keys.left:
                if (!slots) {
                    return;
                }
                event.syntheticEvent.preventDefault();
                dispatchFocusedSlots({ type: SLOTS_FOCUS_ACTION.left, slot: slot }, event.syntheticEvent);
                break;
            case Keys.right:
                if (!slots) {
                    return;
                }
                event.syntheticEvent.preventDefault();
                dispatchFocusedSlots({ type: SLOTS_FOCUS_ACTION.right, slot: slot }, event.syntheticEvent);
                break;
            case Keys.up:
                if (!slots) {
                    return;
                }
                event.syntheticEvent.preventDefault();
                dispatchFocusedSlots({ type: SLOTS_FOCUS_ACTION.up, slot: slot }, event.syntheticEvent);
                break;
            case Keys.down:
                if (!slots) {
                    return;
                }
                event.syntheticEvent.preventDefault();
                dispatchFocusedSlots({ type: SLOTS_FOCUS_ACTION.down, slot: slot }, event.syntheticEvent);
                break;
            case Keys.enter:
                if (!slots || !editable.add) {
                    return;
                }
                var dataItem = createDataItemFromSlot();
                setFormItem(dataItem);
                break;
            case Keys.tab:
                nextItem = findFirstItem(event.target);
                break;
            default:
                break;
        }
        if (nextItem) {
            event.syntheticEvent.preventDefault();
            if (nextItem.element) {
                nextItem.element.focus();
            }
        }
    }, [createDataItemFromSlot, dispatchFocusedSlots, editable.add, setFormItem, slots]);
    var handleEditFormSubmit = React.useCallback(function (event) {
        if (onDataAction) {
            onDataAction.call(undefined, {
                type: DATA_ACTION.create,
                series: false,
                dataItem: event.value
            }, event);
        }
        setFormItem(null, event.syntheticEvent);
    }, [
        onDataAction,
        setFormItem
    ]);
    var handleEditFormCancel = React.useCallback(function (event) {
        setFormItem(null, event.syntheticEvent);
    }, [setFormItem]);
    var handleEditFormClose = React.useCallback(function (event) {
        setFormItem(null, event);
    }, [setFormItem]);
    var handleFormItemChange = React.useCallback(function (value, event) {
        if (!setFormItem) {
            return;
        }
        setFormItem(value, event);
    }, [setFormItem]);
    React.useEffect(function () {
        var isFirst = slots.length && slots[0].current === slot.current;
        setTabIndex(props.tabIndex !== undefined
            ? props.tabIndex === null
                ? undefined
                : props.tabIndex
            : selectedSlots.length === 0
                ? isFirst && items.length === 0
                    ? 0
                    : undefined
                : undefined);
    }, [items, props.tabIndex, selectedSlots.length, slots]);
    return (React.createElement(SchedulerEditSlotContext, { props: props, form: [formItem, handleFormItemChange] },
        React.createElement(ViewSlot, __assign({}, viewSlotProps, { _ref: slot, selected: selected, tabIndex: tabIndex, 
            // Focus
            onFocus: handleFocus, 
            // Mouse
            onDoubleClick: handleDoubleClick, 
            // Keyboard
            onKeyDown: handleKeyDown })),
        (formItem) && (React.createElement(Form, { dataItem: formItem, onSubmit: handleEditFormSubmit, onClose: handleEditFormClose, onCancel: handleEditFormCancel }))));
});
var defaultProps = {
    viewSlot: SchedulerViewSlot,
    form: SchedulerForm
};
SchedulerEditSlot.defaultProps = defaultProps;
SchedulerEditSlot.displayName = 'KendoReactSchedulerEditSlot';
