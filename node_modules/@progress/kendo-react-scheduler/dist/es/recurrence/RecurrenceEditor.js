var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import { useLocalization, useInternationalization } from '@progress/kendo-react-intl';
import { messages, recurrenceEditorEndLabel, recurrenceEditorEndAfter, recurrenceEditorEndNever, recurrenceEditorEndOccurrence, recurrenceEditorEndOn, recurrenceEditorWeeklyRepeatOn, recurrenceEditorYearlyRepeatOn, recurrenceEditorMonthlyRepeatOn, recurrenceEditorMonthlyDay, recurrenceEditorYearlyOf, recurrenceEditorRepeat } from '../messages';
import { serializeRule } from '@progress/kendo-recurrence';
import { toLocalDate, ZonedDate } from '@progress/kendo-date-math';
import { RecurrenceFrequencyEditor } from './RecurrenceFrequencyEditor';
import { RecurrenceRepeatOnWeekEditor } from './RecurrenceRepeatOnWeekEditor';
import { getRule, getUntil, getMonths, getWeekDays, getExtendedWeekDays, getEndRule, getMonthDay, getRepeatOnRule, weekDayRuleFromString, getOffsets, capitalize, getFrequencies, getFrequency, getWeekDay, getMonth, getOffset } from './common';
import { Label } from '@progress/kendo-react-labels';
import { NumericTextBox, RadioGroup } from '@progress/kendo-react-inputs';
import { DropDownList } from '@progress/kendo-react-dropdowns';
import { DatePicker } from '@progress/kendo-react-dateinputs';
import { useSchedulerPropsContext } from '../context';
/** @hidden */
export var RecurrenceEditor = function (props) {
    var intl = useInternationalization();
    var localization = useLocalization();
    var timezone = useSchedulerPropsContext().timezone;
    var _a = React.useState(1), defaultCount = _a[0], setDefaultCount = _a[1];
    var _b = React.useState(ZonedDate.fromUTCDate(props.start)), defaultUntil = _b[0], setDefaultUntil = _b[1];
    var localizeMessage = React.useCallback(function (baseMassage, removePrepend) {
        var message = removePrepend ? baseMassage : 'scheduler.recurrenceEditor' + baseMassage;
        return localization.toLanguageString(message, messages[message]);
    }, [localization]);
    var rrule = React.useMemo(function () { return getRule(props.value); }, [props.value]);
    var frequencies = React.useMemo(function () { return getFrequencies(localizeMessage); }, [localizeMessage]);
    var frequency = React.useMemo(function () { return getFrequency(rrule); }, [rrule]);
    var extendedWeekDays = React.useMemo(function () { return getExtendedWeekDays(intl, localizeMessage); }, [intl, localizeMessage]);
    var weekDay = React.useMemo(function () { return getWeekDay(extendedWeekDays, rrule, props.start); }, [extendedWeekDays, rrule, props.start]);
    var months = React.useMemo(function () { return getMonths(intl); }, [intl]);
    var month = React.useMemo(function () { return getMonth(months, rrule); }, [months, rrule]);
    var offsets = React.useMemo(function () { return getOffsets(localizeMessage); }, [localizeMessage]);
    var offset = React.useMemo(function () { return getOffset(offsets, rrule); }, [offsets, rrule]);
    var endRule = React.useMemo(function () { return getEndRule(rrule); }, [rrule]);
    var monthDay = React.useMemo(function () { return getMonthDay(rrule, props.start); }, [rrule, props.start]);
    var until = React.useMemo(function () { return getUntil(rrule); }, [rrule.until]);
    var weekDays = React.useMemo(function () { return getWeekDays(intl); }, [intl]);
    var repeatOnRule = React.useMemo(function () { return getRepeatOnRule(rrule); }, [rrule.byWeekDay, rrule.byMonthDay]);
    var onChangeHandler = React.useCallback(function (newRrule) {
        if (newRrule.freq === 'never') {
            props.onChange({ value: null });
        }
        else {
            if (newRrule.weekStart === undefined) {
                newRrule.weekStart = intl.firstDay();
            }
            props.onChange({ value: serializeRule(newRrule, props.timezone) });
        }
    }, [props.onChange, props.timezone]);
    var handleFrequencyChange = React.useCallback(function (newFreq) {
        var newRrule = {};
        newRrule.freq = newFreq;
        newRrule.interval = 1;
        if (newFreq === 'weekly') {
            newRrule.byWeekDay = [{
                    day: ZonedDate.fromLocalDate(props.start, timezone).getDay(),
                    offset: 0
                }];
        }
        if (newFreq === 'monthly' || newFreq === 'yearly') {
            newRrule.byMonthDay = [props.start.getDate()];
        }
        if (newFreq === 'yearly') {
            newRrule.byMonth = [props.start.getMonth() + 1];
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, props.start, timezone]);
    var handleIntervalChange = React.useCallback(function (event) {
        var newInterval = event.value;
        onChangeHandler(Object.assign({}, rrule, {
            interval: newInterval
        }));
    }, [onChangeHandler, rrule]);
    var handleCountChange = React.useCallback(function (event) {
        var newCount = event.value;
        onChangeHandler(Object.assign({}, rrule, {
            count: newCount
        }));
        if (newCount !== null) {
            setDefaultCount(newCount);
        }
    }, [onChangeHandler, rrule]);
    var handleUntilChange = React.useCallback(function (event) {
        var newUntil = event.value;
        if (!newUntil) {
            return;
        }
        var value = ZonedDate.fromLocalDate(newUntil, props.timezone);
        onChangeHandler(Object.assign({}, rrule, {
            until: value
        }));
        setDefaultUntil(value);
    }, [onChangeHandler, rrule, props.timezone]);
    var handleWeekDaysChange = React.useCallback(function (newWeekDays) {
        onChangeHandler(Object.assign({}, rrule, {
            byWeekDay: weekDays
                .filter(function (wd) { return newWeekDays.some(function (nwd) { return nwd === wd.value; }); })
                .map(function (wd) { return ({ offset: 0, day: wd.value }); })
        }));
    }, [onChangeHandler, rrule, weekDays]);
    var handleWeekDayChange = React.useCallback(function (event) {
        var newRrule = Object.assign({}, rrule);
        var newWeekDay = event.target.value;
        if (typeof newWeekDay.value === 'string') {
            /* day, weekday or weekend */
            newRrule.byWeekDay = weekDayRuleFromString(newWeekDay.value);
            newRrule.bySetPosition = [offset.value];
        }
        else {
            /* specific weekday */
            newRrule.byWeekDay = [{
                    day: newWeekDay.value,
                    offset: offset.value
                }];
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, rrule]);
    var handleMonthDayChange = React.useCallback(function (event) {
        onChangeHandler(Object.assign({}, rrule, {
            byMonthDay: [event.value]
        }));
    }, [onChangeHandler, rrule]);
    var handleMonthChange = React.useCallback(function (event) {
        var newMonth = event.value;
        onChangeHandler(Object.assign({}, rrule, {
            byMonth: [newMonth.value]
        }));
    }, [onChangeHandler, rrule]);
    var handleEndRuleChange = React.useCallback(function (event) {
        var newEnd = event.value;
        var newRrule = Object.assign({}, rrule);
        switch (newEnd) {
            case 'never':
                newRrule.until = undefined;
                newRrule.count = undefined;
                break;
            case 'count':
                newRrule.until = undefined;
                newRrule.count = defaultCount;
                break;
            case 'until':
                newRrule.until = defaultUntil;
                newRrule.count = undefined;
                break;
            default:
                break;
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, rrule, props.timezone]);
    var handleRepeatOnRuleChange = React.useCallback(function (event) {
        var newRrule = Object.assign({}, rrule);
        if (event.value === 'monthday') {
            newRrule.byWeekDay = undefined;
            newRrule.bySetPosition = undefined;
            newRrule.byMonthDay = [monthDay];
        }
        else if (event.value === 'weekday') {
            // weekDays
            newRrule.byMonthDay = undefined;
            if (typeof weekDay.value === 'string') {
                /* day, weekday or weekend */
                newRrule.bySetPosition = [offset.value];
                newRrule.byWeekDay = weekDayRuleFromString(weekDay.value);
            }
            else {
                /* specific weekday */
                newRrule.byWeekDay = [{
                        day: weekDay.value,
                        offset: offset.value
                    }];
            }
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, rrule, monthDay, weekDay]);
    var handleOffsetChange = React.useCallback(function (event) {
        var newRrule = Object.assign({}, rrule);
        var newOffset = event.value;
        if (newRrule.byWeekDay) {
            var weekDaysCount = newRrule.byWeekDay.length;
            switch (weekDaysCount) {
                case 7:
                case 5:
                case 2:
                    newRrule.bySetPosition = [newOffset.value];
                    break;
                case 1:
                    newRrule.byWeekDay[0].offset = newOffset.value;
                    break;
                default:
                    break;
            }
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, rrule]);
    return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: "k-form-field" },
            React.createElement(Label, null, localization.toLanguageString(recurrenceEditorRepeat, messages[recurrenceEditorRepeat])),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(RecurrenceFrequencyEditor, { value: frequency, data: frequencies, onChange: handleFrequencyChange }))),
        (frequency !== 'never') && (React.createElement("div", { className: 'k-form-field' },
            React.createElement(Label, { editorId: "interval-editor" }, localizeMessage(capitalize(frequency) + 'RepeatEvery')),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement("div", { style: { display: 'flex', alignItems: 'center' } },
                    React.createElement(NumericTextBox, { min: 1, step: 1, defaultValue: 1, value: rrule.interval, onChange: handleIntervalChange, id: "interval-editor" }),
                    "\u00A0",
                    React.createElement(Label, { editorId: "interval-editor" }, localizeMessage(capitalize(frequency) + 'Interval')))))),
        (frequency === 'weekly') && (React.createElement("div", { className: "k-form-field" },
            React.createElement(Label, null, localizeMessage(recurrenceEditorWeeklyRepeatOn, true)),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(RecurrenceRepeatOnWeekEditor, { data: weekDays, value: (rrule.byWeekDay || []).map(function (_a) {
                        var day = _a.day;
                        return day;
                    }), onChange: handleWeekDaysChange })))),
        (frequency === 'monthly') && (React.createElement("div", { className: "k-form-field" },
            React.createElement(Label, { key: "recurrence-repeat-on-monthly-label" }, localizeMessage(recurrenceEditorMonthlyRepeatOn, true)),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(RadioGroup, { value: repeatOnRule, onChange: handleRepeatOnRuleChange, item: RadioGroupListItem, className: "k-reset", data: [
                        {
                            value: 'monthday',
                            label: localizeMessage(recurrenceEditorMonthlyDay, true),
                            children: [
                                React.createElement(React.Fragment, { key: "separator" }, "\u00A0"),
                                React.createElement(NumericTextBox, { key: 'weekday-day', min: 1, max: 31, disabled: repeatOnRule !== 'monthday', value: rrule && rrule.byMonthDay && rrule.byMonthDay[0], onChange: handleMonthDayChange, width: 'auto' })
                            ]
                        },
                        {
                            value: 'weekday',
                            label: ' ',
                            children: [
                                React.createElement(DropDownList, { key: "weekday-offset", textField: "text", dataItemKey: "value", disabled: repeatOnRule !== 'weekday', data: offsets, value: offset, onChange: handleOffsetChange, style: { width: 'auto' } }),
                                React.createElement(React.Fragment, { key: "separator" }, "\u00A0"),
                                React.createElement(DropDownList, { key: "weekday-value", disabled: repeatOnRule !== 'weekday', value: weekDay, data: extendedWeekDays, onChange: handleWeekDayChange, textField: "text", dataItemKey: "value", style: { width: 'auto' } })
                            ]
                        }
                    ] })))),
        (frequency === 'yearly') && (React.createElement("div", { className: "k-form-field" },
            React.createElement(Label, null, localizeMessage(recurrenceEditorYearlyRepeatOn, true)),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(RadioGroup, { value: repeatOnRule, item: RadioGroupListItem, onChange: handleRepeatOnRuleChange, className: "k-reset", data: [
                        {
                            value: 'monthday',
                            label: ' ',
                            children: [
                                React.createElement(DropDownList, { key: "monthday-month", disabled: repeatOnRule !== 'monthday', value: month, data: months, textField: "text", dataItemKey: "value", onChange: handleMonthChange, style: { width: 'auto' } }),
                                React.createElement(React.Fragment, { key: "separator" }, "\u00A0"),
                                React.createElement(NumericTextBox, { key: "monthday-day", min: 1, max: 31, disabled: repeatOnRule !== 'monthday', value: monthDay, onChange: handleMonthDayChange, width: 'auto' })
                            ]
                        },
                        {
                            value: 'weekday',
                            label: ' ',
                            children: [
                                React.createElement(DropDownList, { key: "yearly-weekday-offset", textField: "text", dataItemKey: "value", disabled: repeatOnRule !== 'weekday', data: offsets, value: offset, onChange: handleOffsetChange, style: { width: 'auto' } }),
                                React.createElement(React.Fragment, { key: "yearly-separator-1" }, "\u00A0"),
                                React.createElement(DropDownList, { key: "yearly-weekday-day", textField: "text", dataItemKey: "value", disabled: repeatOnRule !== 'weekday', value: weekDay, data: extendedWeekDays, onChange: handleWeekDayChange, style: { width: 'auto' } }),
                                React.createElement(React.Fragment, { key: "yearly-separator-2" }, "\u00A0"),
                                React.createElement("span", { key: "yearly-weekday-of-label" },
                                    localizeMessage(recurrenceEditorYearlyOf, true),
                                    "\u00A0"),
                                React.createElement(React.Fragment, { key: "yearly-separator-3" }, "\u00A0"),
                                React.createElement(DropDownList, { key: "yearly-weekday-month", textField: "text", dataItemKey: "value", disabled: repeatOnRule !== 'weekday', value: month, data: months, onChange: handleMonthChange, style: { width: 'auto' } })
                            ]
                        }
                    ] })))),
        (frequency !== 'never') && (React.createElement("div", { className: "k-form-field" },
            React.createElement(Label, null, localizeMessage(recurrenceEditorEndLabel, true)),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(RadioGroup, { item: RadioGroupListItem, value: endRule, onChange: handleEndRuleChange, data: [
                        {
                            value: 'never',
                            label: localizeMessage(recurrenceEditorEndNever, true)
                        },
                        {
                            value: 'count',
                            label: localizeMessage(recurrenceEditorEndAfter, true),
                            children: [
                                React.createElement(React.Fragment, { key: "separator-1" }, "\u00A0"),
                                React.createElement(NumericTextBox, { key: "endrule-after-editor", id: "k-endrule-after", min: 1, width: '70px', value: endRule === 'count' ? rrule.count : defaultCount, onChange: handleCountChange, disabled: endRule !== 'count' }),
                                React.createElement(React.Fragment, { key: "separator-2" }, "\u00A0"),
                                React.createElement(Label, { key: "endrule-after-label", className: 'k-radio-label', editorId: 'k-endrule-after' }, localizeMessage(recurrenceEditorEndOccurrence, true))
                            ]
                        },
                        {
                            value: 'until',
                            label: localizeMessage(recurrenceEditorEndOn, true),
                            children: [
                                React.createElement(React.Fragment, { key: "separator" }, "\u00A0"),
                                React.createElement(DatePicker, { key: "k-endrule-until-editor", id: "k-endrule-until", disabled: endRule !== 'until', min: props.start, value: endRule === 'until' ? until : toLocalDate(defaultUntil), onChange: handleUntilChange, width: 'auto' })
                            ]
                        }
                    ] }))))));
};
var RadioGroupListItem = function (props) {
    return (React.createElement("li", __assign({}, props, { style: { display: 'flex', alignItems: 'center', minHeight: 30 } }), props.children));
};
RecurrenceEditor.defaultProps = {
    value: ''
};
RecurrenceEditor.displayName = 'KendoReactSchedulerRepeatEditor';
