import { isPresent, isNullOrEmptyString } from '../utils';
import { parseRule } from '@progress/kendo-recurrence';
import { toLocalDate } from '@progress/kendo-date-math';
/** @hidden */
export var capitalize = function (value) { return value.charAt(0).toUpperCase() + value.slice(1); };
/** @hidden */
export var OFFSET_POSITIONS = ['first', 'second', 'third', 'fourth', 'last'];
/** @hidden */
export var FREQUENCIES = ['never', 'daily', 'weekly', 'monthly', 'yearly'];
/** @hidden */
export var dayRule = [
    { day: 0, offset: 0 },
    { day: 1, offset: 0 },
    { day: 2, offset: 0 },
    { day: 3, offset: 0 },
    { day: 4, offset: 0 },
    { day: 5, offset: 0 },
    { day: 6, offset: 0 }
];
/** @hidden */
export var weekdayRule = [
    { day: 1, offset: 0 },
    { day: 2, offset: 0 },
    { day: 3, offset: 0 },
    { day: 4, offset: 0 },
    { day: 5, offset: 0 }
];
/** @hidden */
export var weekendRule = [
    { day: 0, offset: 0 },
    { day: 6, offset: 0 }
];
/** @hidden */
export var weekDayRuleFromString = function (weekDay) {
    switch (weekDay) {
        case 'day':
            return dayRule;
        case 'weekday':
            return weekdayRule;
        case 'weekend':
            return weekendRule;
        default:
            break;
    }
    return;
};
/** @hidden */
export var getRule = function (recurrenceRule) {
    return parseRule({ recurrenceRule: recurrenceRule }) || {};
};
/** @hidden */
export var getFrequencies = function (localizeMessage) {
    return FREQUENCIES.map(function (freq) { return ({
        value: freq,
        text: localizeMessage('Frequencies' + capitalize(freq))
    }); });
};
/** @hidden */
export var getFrequency = function (rrule) {
    if (isPresent(rrule) && !isNullOrEmptyString(rrule.freq)) {
        return rrule.freq;
    }
    return 'never';
};
/** @hidden */
export var getUntil = function (rrule) {
    if (isPresent(rrule.until)) {
        return toLocalDate(rrule.until);
    }
    return null;
};
/** @hidden */
export var getMonths = function (intl) {
    return intl.dateFormatNames({
        type: 'months',
        nameType: 'wide',
        standAlone: true
    }).map(function (month, idx) { return ({
        text: month,
        value: idx + 1
    }); });
};
/** @hidden */
export var getWeekDays = function (intl) {
    var firstDay = intl.firstDay();
    var abbrNames = intl.dateFormatNames({
        type: 'days',
        nameType: 'abbreviated'
    }).map(function (day, idx) { return ({
        text: day,
        value: idx
    }); });
    /* Sorting according to first week day */
    return (abbrNames.slice(firstDay)).concat(abbrNames.slice(0, firstDay));
};
/** @hidden */
export var getWeekDay = function (weekDays, rrule, start) {
    return weekDays.find(function (item) {
        var value;
        if (isPresent(rrule.byWeekDay)) {
            var weekDaysCount = rrule.byWeekDay.length;
            switch (weekDaysCount) {
                case 7:
                    value = 'day';
                    break;
                case 5:
                    value = 'weekday';
                    break;
                case 2:
                    value = 'weekend';
                    break;
                case 1:
                    value = rrule.byWeekDay[0].day;
                    break;
                default:
                    value = start.getDay();
                    break;
            }
        }
        return value === item.value;
    }) || weekDays[0];
};
/** @hidden */
export var getExtendedWeekDays = function (intl, localizeMessage) {
    var firstDay = intl.firstDay();
    var wideNames = intl.dateFormatNames({
        type: 'days',
        nameType: 'wide'
    }).map(function (day, idx) { return ({
        text: day,
        value: idx
    }); });
    var sortedWideNames = (wideNames.slice(firstDay)).concat(wideNames.slice(0, firstDay));
    var specialRules = [
        { text: localizeMessage('WeekdaysDay'), value: 'day' },
        { text: localizeMessage('WeekdaysWeekday'), value: 'weekday' },
        { text: localizeMessage('WeekdaysWeekendday'), value: 'weekend' }
    ];
    return specialRules.concat(sortedWideNames);
};
/** @hidden */
export var getOffset = function (offsets, rrule) {
    return offsets.find(function (offset) { return offset.value === (rrule.bySetPosition
        ? rrule.bySetPosition[0]
        : rrule.byWeekDay && rrule.byWeekDay[0]
            ? rrule.byWeekDay[0].offset
            : 1); }) || offsets[0];
};
/** @hidden */
export var getOffsets = function (localizeMessage) {
    var values = [1, 2, 3, 4, -1];
    return OFFSET_POSITIONS.map(function (offset, idx) { return ({
        text: localizeMessage('OffsetPositions' + capitalize(offset)),
        value: values[idx]
    }); });
};
/** @hidden */
export var getEndRule = function (rrule) {
    if (isPresent(rrule.count)) {
        return 'count';
    }
    else if (isPresent(rrule.until)) {
        return 'until';
    }
    else {
        return 'never';
    }
};
/** @hidden */
export var getRepeatOnRule = function (rrule) {
    if (isPresent(rrule.byWeekDay)) {
        return 'weekday';
    }
    else if (isPresent(rrule.byMonthDay)) {
        return 'monthday';
    }
};
/** @hidden */
export var getMonth = function (months, rrule) {
    return months.find(function (month) { return (rrule.byMonth ? rrule.byMonth[0] : null) === month.value; }) || months[0];
};
/** @hidden */
export var getMonthDay = function (rrule, start) {
    if (isPresent(rrule.byMonthDay) && rrule.byMonthDay.length > 0) {
        return rrule.byMonthDay[0];
    }
    else {
        return start.getDate();
    }
};
/** @hidden */
export var getUntilEnd = function (start, until) {
    var currentStart = start;
    var currentUntil = until;
    if (isPresent(currentUntil)) {
        return currentUntil;
    }
    else {
        return new Date(currentStart.getFullYear(), currentStart.getMonth(), currentStart.getDate(), 23, 59, 59);
    }
};
/** @hidden */
export var getUntilMin = function (start, until) {
    var currentStart = start;
    var currentUntil = until;
    if (isPresent(currentUntil) && currentUntil < currentStart) {
        return currentUntil;
    }
    else {
        return currentStart;
    }
};
