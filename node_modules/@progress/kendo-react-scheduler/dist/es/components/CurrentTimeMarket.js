import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { cloneDate } from '@progress/kendo-date-math';
import { classNames, useDir } from '@progress/kendo-react-common';
import { useSchedulerElementContext, useSchedulerPropsContext, useSchedulerViewSlotsContext } from '../context';
import { first, isInTimeRange, intersects } from '../utils';
import { getRect } from '../views/common/utils';
var combineWidths = function (slots) {
    var result = 0;
    slots.forEach(function (slot) {
        if (slot.current) {
            var rect = getRect(slot.current.element);
            result += rect.width;
        }
    });
    return result;
};
var combineHeights = function (slots) {
    var result = 0;
    slots.forEach(function (slot) {
        if (slot.current) {
            var rect = getRect(slot.current.element);
            result += rect.height;
        }
    });
    return result;
};
var setTime = function (origin, candidate) {
    var date = cloneDate(origin);
    date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());
    return date;
};
/** @hidden */
export var CurrentTimeMarker = function (props) {
    var _a;
    var _b = React.useState(false), show = _b[0], setShow = _b[1];
    var scheduler = useSchedulerElementContext();
    var schedulerProps = useSchedulerPropsContext();
    var interval = React.useRef(undefined);
    var arrowRef = React.useRef(null);
    var line = React.useRef(null);
    var updateInterval = props.updateInterval || defaultProps.updateInterval;
    var _c = React.useState(false), setForce = _c[1];
    var dir = useDir(line, schedulerProps.rtl === true ? 'rtl' : undefined);
    var slots = useSchedulerViewSlotsContext()[0];
    var position = React.useCallback(function () {
        if (!slots) {
            return;
        }
        var sameTimeSlots = slots
            .filter(function (s) { return s.current
            && (props.groupIndex === undefined || props.groupIndex === null || s.current.props.group.index === props.groupIndex)
            && (props.vertical
                ? intersects(new Date(), new Date(), s.current.props.start, s.current.props.end, true)
                : isInTimeRange(new Date(), s.current.props.start, s.current.props.end))
            && !s.current.props.isAllDay; });
        if (sameTimeSlots && sameTimeSlots.length && arrowRef.current && line.current) {
            var firstSlot = first(sameTimeSlots);
            if (!firstSlot.current) {
                return;
            }
            var size = props.vertical
                ? combineHeights(sameTimeSlots)
                : combineWidths(sameTimeSlots);
            var rect = getRect(firstSlot.current.element);
            var arrowRect = getRect(arrowRef.current);
            var pxPerMillisecond = (props.vertical ? rect.width : rect.height)
                / (firstSlot.current.props.end.getTime() - firstSlot.current.props.start.getTime());
            var offset = (Date.now() - setTime(new Date(), firstSlot.current.props.start).getTime()) * pxPerMillisecond;
            var rtl = dir === 'rtl';
            var top_1 = props.vertical
                ? rect.top
                : rect.top + offset - (arrowRect.height / 2);
            var horizontalDimension = rtl ? 'right' : 'left';
            var horizontalMeasure = props.vertical
                ? rect[horizontalDimension] + offset - (arrowRect.width / 2)
                : rect[horizontalDimension];
            if (props.vertical) {
                arrowRef.current.style[horizontalDimension] = "".concat(horizontalMeasure, "px");
            }
            else {
                arrowRef.current.style.top = "".concat(top_1, "px");
            }
            line.current.style[horizontalDimension] = "".concat(horizontalMeasure, "px");
            line.current.style.top = "".concat(top_1, "px");
            line.current.style[props.vertical ? 'height' : 'width'] = "".concat(size - 1, "px");
            setShow(true);
        }
        else {
            setShow(false);
        }
    }, [slots, props.groupIndex, props.vertical, dir]);
    var refresh = React.useCallback(function () {
        position();
        setForce(function (f) { return !f; });
    }, [position]);
    React.useEffect(function () {
        if (!scheduler.current || !window) {
            return;
        }
        clearInterval(interval.current);
        interval.current = window.setInterval(refresh, updateInterval);
        var observer = new window.ResizeObserver(refresh);
        observer.observe(scheduler.current);
        return function () {
            clearInterval(interval.current);
            observer.disconnect();
        };
    }, [position, refresh, scheduler, updateInterval]);
    React.useEffect(position);
    var arrow = (React.createElement("div", { ref: arrowRef, className: classNames('k-current-time', {
            'k-current-time-arrow-right': !props.vertical && dir !== 'rtl',
            'k-current-time-arrow-left': !props.vertical && dir === 'rtl',
            'k-current-time-arrow-down': props.vertical
        }), style: {
            transform: props.vertical
                ? dir === 'rtl'
                    ? 'translateX(50%)'
                    : 'translateX(-50%)'
                : 'translateY(-50%)',
            visibility: !show ? 'hidden' : undefined
        } }));
    return (React.createElement(React.Fragment, null,
        (props.attachArrow && props.attachArrow.current) ? ReactDOM.createPortal(arrow, props.attachArrow.current) : arrow,
        React.createElement("div", { className: "k-current-time", ref: line, style: (_a = {
                    transform: props.vertical ? 'translateX(-50%)' : 'translateY(-50%)'
                },
                _a[props.vertical ? 'width' : 'height'] = '1px',
                _a.visibility = !show ? 'hidden' : undefined,
                _a) })));
};
var defaultProps = {
    updateInterval: 60000
};
CurrentTimeMarker.defaultProps = defaultProps;
