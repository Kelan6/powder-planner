var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import { canUseDOM } from '@progress/kendo-react-common';
import { Button } from '@progress/kendo-react-buttons';
import { Form } from '@progress/kendo-react-form';
import { Dialog as KendoDialog, DialogActionsBar } from '@progress/kendo-react-dialogs';
import { useLocalization } from '@progress/kendo-react-intl';
import { SchedulerFormEditor } from '../editors/SchedulerFormEditor';
import { useSchedulerFieldsContext } from '../context';
import { messages, editorValidationRequired, editorValidationStart, editorValidationEnd, editorSave, editorCancel, editorTitle } from '../messages';
/**
 * Represents the default `form` component rendered by the [SchedulerEditItem]({% slug api_scheduler_scheduleredititem %}) and [SchedulerEditSlot]({% slug api_scheduler_schedulereditslot %}) components.
 *
 * Accepts [SchedulerFormProps]({ slug api_scheduler_schedulerformprops }) properties and provide [SchedulerFormHandle]({% slug api_scheduler_schedulerformhandle %}) `ref` callback.
 */
export var SchedulerForm = React.forwardRef(function (props, ref) {
    var onCancel = props.onCancel, onClose = props.onClose, onSubmit = props.onSubmit, Editor = props.editor, _a = props.dialog, Dialog = _a === void 0 ? defaultProps.dialog : _a, _b = props.validator, validator = _b === void 0 ? defaultProps.validator : _b, other = __rest(props, ["onCancel", "onClose", "onSubmit", "editor", "dialog", "validator"]);
    var form = React.useRef(null);
    React.useImperativeHandle(form, function () { return ({ props: props }); });
    React.useImperativeHandle(ref, function () { return form.current; });
    var localization = useLocalization();
    var fields = useSchedulerFieldsContext();
    var requiredValidationMessage = React.useMemo(function () { return localization.toLanguageString(editorValidationRequired, messages[editorValidationRequired]); }, [localization]);
    var endValidationMessage = React.useMemo(function () { return localization.toLanguageString(editorValidationEnd, messages[editorValidationEnd]); }, [localization]);
    var editSaveMessage = React.useMemo(function () { return localization.toLanguageString(editorSave, messages[editorSave]); }, [localization]);
    var editCancelMessage = React.useMemo(function () { return localization.toLanguageString(editorCancel, messages[editorCancel]); }, [localization]);
    var editorTitleMessage = React.useMemo(function () { return localization.toLanguageString(editorTitle, messages[editorTitle]); }, [localization]);
    var startValidationMessage = React.useMemo(function () { return localization.toLanguageString(editorValidationStart, messages[editorValidationStart]); }, [localization]);
    var handleCancel = React.useCallback(function (syntheticEvent) {
        if (onCancel) {
            onCancel.call(undefined, { value: null, syntheticEvent: syntheticEvent, target: form.current });
        }
    }, [onCancel]);
    var handleClose = React.useCallback(function (_a) {
        var syntheticEvent = _a.syntheticEvent;
        if (onClose) {
            onClose.call(undefined, { value: null, syntheticEvent: syntheticEvent, target: form.current });
        }
    }, [onClose]);
    var handleSubmit = React.useCallback(function (dataItem, syntheticEvent) {
        if (onSubmit) {
            onSubmit.call(undefined, { value: dataItem, syntheticEvent: syntheticEvent, target: form.current });
        }
    }, [onSubmit]);
    var startAfterEndValidator = React.useCallback(function (value, formValueGetter) { return (Boolean(value && formValueGetter(fields.end) && value.getTime() > formValueGetter(fields.end).getTime()) ?
        startValidationMessage :
        undefined); }, [fields, startValidationMessage]);
    var endAfterStartValidator = React.useCallback(function (value, formValueGetter) { return (Boolean(value && formValueGetter(fields.start) && value.getTime() < formValueGetter(fields.start).getTime()) ?
        endValidationMessage :
        undefined); }, [fields, endValidationMessage]);
    var requiredValidator = React.useCallback(function (value) { return (value ? undefined : requiredValidationMessage); }, [requiredValidationMessage]);
    var formValidator = React.useCallback(function (_dataItem, formValueGetter) {
        var result = {};
        result[fields.start] = [
            requiredValidator(formValueGetter(fields.start)),
            startAfterEndValidator(formValueGetter(fields.start), formValueGetter)
        ].filter(Boolean).reduce(function (current, acc) { return current || acc; }, '');
        result[fields.end] = [
            requiredValidator(formValueGetter(fields.start)),
            endAfterStartValidator(formValueGetter(fields.start), formValueGetter)
        ].filter(Boolean).reduce(function (current, acc) { return current || acc; }, '');
        var additionalValidator = validator(_dataItem, formValueGetter);
        return __assign(__assign({}, result), additionalValidator);
    }, [endAfterStartValidator, fields.end, fields.start, requiredValidator, startAfterEndValidator, validator]);
    return canUseDOM
        ? ReactDOM.createPortal((React.createElement(Form, __assign({ initialValues: props.dataItem, onSubmit: handleSubmit, validator: formValidator, render: function (renderProps) { return (React.createElement(Dialog, { title: editorTitleMessage, minWidth: 600, onClose: handleClose, className: "k-scheduler-edit-dialog" },
                React.createElement(SchedulerFormEditor, __assign({}, renderProps, { as: Editor })),
                React.createElement(DialogActionsBar, null,
                    React.createElement(Button, { disabled: !renderProps.allowSubmit, onClick: renderProps.onSubmit }, editSaveMessage),
                    React.createElement(Button, { onClick: handleCancel }, editCancelMessage)))); } }, other))), document && document.body)
        : null;
});
var defaultProps = {
    dialog: KendoDialog,
    validator: function () { return ({}); }
};
SchedulerForm.defaultProps = defaultProps;
SchedulerForm.displayName = 'KendoReactSchedulerForm';
