var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import { intersects } from '../utils';
import { orderBy } from '@progress/kendo-data-query';
import { ZonedDate } from '@progress/kendo-date-math';
/** @hidden */
export var toItems = function (occurrences, _a, _b) {
    var timezone = _a.timezone;
    var groups = _b.groups, ranges = _b.ranges;
    var result = [];
    var sorted = orderBy(occurrences, [
        { field: 'start', dir: 'asc' },
        { field: 'end', dir: 'desc' },
        { field: 'isAllDay', dir: 'desc' }
    ]);
    sorted.forEach(function (occurrence) {
        groups.forEach(function (g) {
            var group = groups.length === 1
                ? personalizedGroup(occurrence, g)
                : g;
            if (inGroup(occurrence, group)) {
                ranges.forEach(function (range) {
                    if (inRange(occurrence, range)) {
                        var itemRef = React.createRef();
                        var _ref = React.createRef();
                        var head = range.end < occurrence.end;
                        var tail = occurrence.start < range.start;
                        var zonedStart = ZonedDate.fromLocalDate(occurrence.start, timezone);
                        var zonedEnd = ZonedDate.fromLocalDate(occurrence.end, timezone);
                        var item = __assign(__assign({}, occurrence), { _ref: _ref, itemRef: itemRef, head: head, tail: tail, order: null, zonedStart: zonedStart, zonedEnd: zonedEnd, group: group, range: range, slots: [], isRecurring: Boolean(occurrence.recurrenceRule), isException: Boolean(!occurrence.recurrenceRule
                                && occurrence.recurrenceId !== null && occurrence.recurrenceId !== undefined), isAllDay: Boolean(occurrence.isAllDay) });
                        result.push(item);
                    }
                });
            }
        });
    });
    return result;
};
var personalizedGroup = function (occurrence, group) {
    return {
        index: 0,
        resources: group.resources.filter(function (resource) { return inResource(occurrence, resource); })
    };
};
var inResource = function (occurrence, resource) {
    return resource.multiple
        ? (occurrence.dataItem[resource.field] || []).some(function (val) { return resource[resource.valueField] === val; })
        : occurrence.dataItem[resource.field] === resource[resource.valueField];
};
/** @hidden */
export var inGroup = function (occurrence, group) {
    return !group.resources.some(function (res) { return res.multiple
        ? !occurrence.dataItem[res.field].some(function (val) { return res[res.valueField] === val; })
        : occurrence.dataItem[res.field] !== res[res.valueField]; });
};
/** @hidden */
export var inSlot = function (occurrence, slot) {
    return intersects(slot.start, slot.end, occurrence.start, occurrence.end);
};
/** @hidden */
export var inRange = function (occurrence, range) {
    return intersects(range.start, range.end, occurrence.start, occurrence.end)
        && (range.isAllDay === undefined
            || occurrence.isAllDay === undefined
            || (occurrence.isAllDay === range.isAllDay));
};
