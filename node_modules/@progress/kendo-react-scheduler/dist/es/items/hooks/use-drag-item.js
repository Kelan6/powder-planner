var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { clone } from '@progress/kendo-react-common';
import * as React from 'react';
import { useSchedulerFieldsContext, useSchedulerGroupsContext, useSchedulerViewSelectedItemsContext } from '../../context';
import { useControlledState } from '../../hooks/useControlledState';
import { DATA_ACTION } from '../../main';
import { getField, setField, slotDive } from '../../utils';
/**
 * Represents the available `action` types for the `SchedulerItemDragItemAction` objects.
 *
 * The available types are:
 * - `DRAG_ITEM_SET'`
 * - `DRAG_ITEM_START'`
 * - `DRAG_ITEM_DRAG'`
 * - `DRAG_ITEM_COMPLETE'`
 * - `DRAG_ITEM_COMPLETE_OCCURRENCE'`
 * - `DRAG_ITEM_COMPLETE_SERIES'`
 * - `DRAG_ITEM_RESET'`
 * - `DRAG_ITEM_DRAG_SELECTED`
 */
export var DRAG_ITEM_ACTION;
(function (DRAG_ITEM_ACTION) {
    DRAG_ITEM_ACTION["set"] = "DRAG_ITEM_SET";
    DRAG_ITEM_ACTION["start"] = "DRAG_ITEM_START";
    DRAG_ITEM_ACTION["drag"] = "DRAG_ITEM_DRAG";
    DRAG_ITEM_ACTION["complete"] = "DRAG_ITEM_COMPLETE";
    DRAG_ITEM_ACTION["completeOccurrence"] = "DRAG_ITEM_COMPLETE_OCCURRENCE";
    DRAG_ITEM_ACTION["completeSeries"] = "DRAG_ITEM_COMPLETE_SERIES";
    DRAG_ITEM_ACTION["reset"] = "DRAG_ITEM_RESET";
    DRAG_ITEM_ACTION["dragSelected"] = "DRAG_ITEM_DRAG_SELECTED";
})(DRAG_ITEM_ACTION || (DRAG_ITEM_ACTION = {}));
;
/** @hidden */
export var useDragItem = function (config, state) {
    var offset = React.useRef(0);
    var initialXRef = React.useRef(0);
    var initialYRef = React.useRef(0);
    var oldSlot = React.useRef(null);
    var _a = useControlledState.apply(void 0, state), dragItem = _a[0], setDragItem = _a[1];
    var selectedItems = useSchedulerViewSelectedItemsContext()[0];
    var fields = useSchedulerFieldsContext();
    var groups = useSchedulerGroupsContext();
    var handleDragItemAction = function (action) {
        switch (action.type) {
            case DRAG_ITEM_ACTION.set: {
                setDragItem(action.payload);
                break;
            }
            case DRAG_ITEM_ACTION.reset: {
                setDragItem(null);
                break;
            }
            case DRAG_ITEM_ACTION.dragSelected: {
                if (Math.abs(initialXRef.current - action.payload.x) < 10
                    && Math.abs(initialYRef.current - action.payload.y) < 10) {
                    return;
                }
                var slot = slotDive(action.payload.x, action.payload.y, 7);
                if (!slot) {
                    return;
                }
                if (slot === oldSlot.current) {
                    return;
                }
                var dataItem = clone(config.dataItem);
                var slotStart = slot.getAttribute('data-slot-start');
                var slotIsAllDay = slot.getAttribute('data-slot-allday') === 'true';
                if (!config.ignoreIsAllDay && slotIsAllDay !== config.isAllDay) {
                    return;
                }
                var itemStart = new Date(getField(dataItem, fields.start));
                var distance_1 = Number(slotStart) - itemStart.getTime();
                var newDragItems = selectedItems.map(function (si) {
                    if (!si.current) {
                        return null;
                    }
                    var selectedDataItem = clone(si.current.props.dataItem);
                    var selectedStart = new Date(si.current.props.start.getTime() + distance_1);
                    var selectedEnd = new Date(si.current.props.end.getTime() + distance_1);
                    setField(selectedDataItem, fields.start, selectedStart);
                    setField(selectedDataItem, fields.end, selectedEnd);
                    return selectedDataItem;
                }).filter(Boolean);
                oldSlot.current = slot;
                setDragItem(__spreadArray([], newDragItems, true));
                break;
            }
            case DRAG_ITEM_ACTION.start: {
                var clientX = action.payload.x;
                var clientY = action.payload.y;
                initialXRef.current = clientX;
                initialYRef.current = clientY;
                var slot = slotDive(clientX, clientY, 7);
                if (!slot) {
                    return;
                }
                var dataItem = clone(config.dataItem);
                var slotStart = slot.getAttribute('data-slot-start');
                var itemStart = getField(dataItem, fields.start);
                if (slotStart === null) {
                    return;
                }
                offset.current = Number(slotStart) - new Date(itemStart).getTime();
                break;
            }
            case DRAG_ITEM_ACTION.drag: {
                if (Math.abs(initialXRef.current - action.payload.x) < 10
                    && Math.abs(initialYRef.current - action.payload.y) < 10) {
                    return;
                }
                var slot = slotDive(action.payload.x, action.payload.y, 7);
                if (!slot) {
                    return;
                }
                if (slot === oldSlot.current) {
                    return;
                }
                var dataItem_1 = clone(config.dataItem);
                var slotStart = slot.getAttribute('data-slot-start');
                var slotGroupIndex_1 = slot.getAttribute('data-slot-group');
                var slotIsAllDay = slot.getAttribute('data-slot-allday') === 'true';
                if (!config.ignoreIsAllDay && slotIsAllDay !== config.isAllDay) {
                    return;
                }
                var itemStart = new Date(getField(dataItem_1, fields.start));
                var itemEnd = new Date(getField(dataItem_1, fields.end));
                var duration = itemEnd.getTime() - itemStart.getTime();
                var start = new Date(Number(slotStart) - Number(offset.current));
                var end = new Date(Number(slotStart) - Number(offset.current) + duration);
                var group = groups.find(function (g) { return g.index === Number(slotGroupIndex_1); });
                setField(dataItem_1, fields.start, start);
                setField(dataItem_1, fields.end, end);
                if (group && groups.length > 1) {
                    group.resources.forEach(function (resource) {
                        if (!resource.multiple) {
                            setField(dataItem_1, resource.field, resource[resource.valueField]);
                        }
                    });
                }
                oldSlot.current = slot;
                if (dataItem_1) {
                    setDragItem(dataItem_1);
                }
                break;
            }
            case DRAG_ITEM_ACTION.complete: {
                setDragItem(null);
                if (config.onDataAction && dragItem) {
                    config.onDataAction.call(undefined, {
                        type: DATA_ACTION.update,
                        series: false,
                        dataItem: dragItem
                    });
                }
                break;
            }
            case DRAG_ITEM_ACTION.completeOccurrence: {
                var newDataItem = Array.isArray(dragItem) ? dragItem.slice() : clone(dragItem);
                setDragItem(null);
                if (config.onDataAction && dragItem) {
                    config.onDataAction.call(undefined, {
                        type: DATA_ACTION.update,
                        series: false,
                        dataItem: newDataItem
                    });
                }
                break;
            }
            case DRAG_ITEM_ACTION.completeSeries: {
                var newDataItems = void 0;
                if (Array.isArray(dragItem)) {
                    newDataItems = dragItem.map(function (di) {
                        var updated = clone(di);
                        setField(updated, fields.start, getField(di, fields.start));
                        setField(updated, fields.end, getField(di, fields.end));
                        return updated;
                    });
                }
                else {
                    var updated = clone(dragItem);
                    setField(updated, fields.start, getField(dragItem, fields.start));
                    setField(updated, fields.end, getField(dragItem, fields.end));
                    newDataItems = updated;
                }
                setDragItem(null);
                if (config.onDataAction && newDataItems) {
                    config.onDataAction.call(undefined, {
                        type: DATA_ACTION.update,
                        series: true,
                        dataItem: newDataItems
                    });
                }
                break;
            }
            default:
                setDragItem(dragItem);
                break;
        }
    };
    return [dragItem, setDragItem, handleDragItemAction];
};
