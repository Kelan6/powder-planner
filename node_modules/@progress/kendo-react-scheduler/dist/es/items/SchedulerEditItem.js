var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import { SchedulerOccurrenceDialog } from '../components/SchedulerOccurrenceDialog';
import { SchedulerForm } from '../components/SchedulerForm';
import { SchedulerRemoveDialog } from '../components/SchedulerRemoveDialog';
import { Keys, guid } from '@progress/kendo-react-common';
import { SchedulerDrag } from '../views/common/SchedulerDrag';
import { SchedulerResize } from '../views/common/SchedulerResize';
import { SchedulerViewItem } from './SchedulerViewItem';
import { ITEMS_FOCUS_ACTION, SLOTS_FOCUS_ACTION, useEditable } from '../hooks';
import { useSchedulerViewFocusedItemsContext, useSchedulerViewFocusedSlotsContext, useSchedulerViewSelectedItemsContext, useSchedulerViewItemsContext, SchedulerItemSelectionContext } from '../context';
import { SchedulerEditItemContext } from '../context/SchedulerEditItemContext';
import { FORM_ITEM_ACTION, useFormItem } from './hooks/use-form-item';
import { SHOW_OCCURRENCE_DIALOG_ACTION, useShowOccurrenceDialog } from './hooks/use-show-occurrence-dialog';
import { REMOVE_ITEM_ACTION, useRemoveItem } from './hooks/use-remove-item';
import { SHOW_REMOVE_DIALOG_ACTION, useShowRemoveDialog } from './hooks/use-show-remove-item-dialog';
import { DRAG_ITEM_ACTION, useDragItem } from './hooks/use-drag-item';
import { RESIZE_ITEM_ACTION, useResizeItem } from './hooks/use-resize-item';
import { SERIES_ACTION, useSeries } from './hooks/use-series';
import { ITEMS_SELECT_ACTION } from '../hooks/use-items-selection';
/**
 * Represents the default `editItem` component rendered by the [KendoReact Scheduler component]({% slug overview_scheduler %}).
 *
 * This is a composite component of the [`SchedulerViewItem`]({% slug api_scheduler_schedulerviewitem %}), extending it to provide editing through drag, resize and external form.
 */
export var SchedulerEditItem = React.forwardRef(function (props, ref) {
    // tslint:enable:max-line-length
    var _ref = props._ref, itemRef = props.itemRef, onDataAction = props.onDataAction, ignoreIsAllDay = props.ignoreIsAllDay, propViewItem = props.viewItem, propSeries = props.series, onSeriesChange = props.onSeriesChange, propForm = props.form, propFormItem = props.formItem, onFormItemChange = props.onFormItemChange, propDrag = props.drag, propDragItem = props.dragItem, onDragItemChange = props.onDragItemChange, propResize = props.resize, propResizeItem = props.resizeItem, onResizeItemChange = props.onResizeItemChange, propRemoveDialog = props.removeDialog, propRemoveItem = props.removeItem, onRemoveItemChange = props.onRemoveItemChange, propOccurrenceDialog = props.occurrenceDialog, propShowOccurrenceDialog = props.showOccurrenceDialog, onShowOccurrenceDialogChange = props.onShowOccurrenceDialogChange, propShowRemoveDialog = props.showRemoveDialog, onShowRemoveDialogChange = props.onShowRemoveDialogChange, onFocus = props.onFocus, onFocusAction = props.onFocusAction, onMouseDown = props.onMouseDown, onMouseDownAction = props.onMouseDownAction, onMouseUp = props.onMouseUp, onMouseUpAction = props.onMouseUpAction, onClick = props.onClick, onClickAction = props.onClickAction, onDoubleClick = props.onDoubleClick, onDoubleClickAction = props.onDoubleClickAction, onRemoveClick = props.onRemoveClick, onRemoveClickAction = props.onRemoveClickAction, onPress = props.onPress, onPressAction = props.onPressAction, onDrag = props.onDrag, onDragAction = props.onDragAction, onRelease = props.onRelease, onReleaseAction = props.onReleaseAction, onResizePress = props.onResizePress, onResizePressAction = props.onResizePressAction, onResizeStartDrag = props.onResizeStartDrag, onResizeStartDragAction = props.onResizeStartDragAction, onResizeEndDrag = props.onResizeEndDrag, onResizeEndDragAction = props.onResizeEndDragAction, onResizeRelease = props.onResizeRelease, onResizeReleaseAction = props.onResizeReleaseAction, onOccurrenceClick = props.onOccurrenceClick, onOccurrenceClickAction = props.onOccurrenceClickAction, onSeriesClick = props.onSeriesClick, onSeriesClickAction = props.onSeriesClickAction, onKeyDown = props.onKeyDown, onKeyDownAction = props.onKeyDownAction, onKeyUp = props.onKeyUp, onKeyUpAction = props.onKeyUpAction, onRemoveConfirm = props.onRemoveConfirm, onRemoveConfirmAction = props.onRemoveConfirmAction, onFormSubmit = props.onFormSubmit, onFormSubmitAction = props.onFormSubmitAction, onCancel = props.onCancel, onCancelAction = props.onCancelAction;
    var _a = React.useState(props.tabIndex), tabIndex = _a[0], setTabIndex = _a[1];
    var editItem = React.useRef(null);
    var item = React.useRef(null);
    var eventId = React.useMemo(function () { return guid(); }, []);
    React.useImperativeHandle(editItem, function () { return ({ props: props, element: item.current && item.current.element }); });
    React.useImperativeHandle(ref, function () { return editItem.current; });
    React.useImperativeHandle(_ref, function () { return item.current; });
    React.useImperativeHandle(itemRef, function () { return item.current; });
    var ViewItem = propViewItem || defaultProps.viewItem;
    var Drag = propDrag || defaultProps.drag;
    var Resize = propResize || defaultProps.resize;
    var Form = propForm || defaultProps.form;
    var OccurrenceDialog = propOccurrenceDialog || defaultProps.occurrenceDialog;
    var RemoveDialog = propRemoveDialog || defaultProps.removeDialog;
    var editable = useEditable(props.editable);
    var _b = useSchedulerViewSelectedItemsContext(), selectedItems = _b[0], dispatchItemSelection = _b[1];
    var _c = useSeries(null, propSeries, onSeriesChange), series = _c[0], dispatchSeries = _c[2];
    var _d = useFormItem({ series: series, onDataAction: onDataAction }, [null, propFormItem, onFormItemChange]), formItem = _d[0], setFormItem = _d[1], dispatchFormItem = _d[2];
    var _e = useDragItem({ dataItem: props.dataItem, ignoreIsAllDay: props.ignoreIsAllDay, isAllDay: props.isAllDay, onDataAction: onDataAction }, [null, propDragItem, onDragItemChange]), dragItem = _e[0], setDragItem = _e[1], dispatchDragItem = _e[2];
    var _f = useResizeItem({ dataItem: props.dataItem, onDataAction: onDataAction }, [null, propResizeItem, onResizeItemChange]), resizeItem = _f[0], setResizeItem = _f[1], dispatchResizeItem = _f[2];
    var _g = useRemoveItem({ series: series, onDataAction: onDataAction }, [null, propRemoveItem, onRemoveItemChange]), removeItem = _g[0], setRemoveItem = _g[1], dispatchRemoveItem = _g[2];
    var _h = useShowRemoveDialog(false, propShowRemoveDialog, onShowRemoveDialogChange), showRemoveDialog = _h[0], setShowRemoveDialog = _h[1], dispatchShowRemoveDialog = _h[2];
    var _j = useShowOccurrenceDialog(false, propShowOccurrenceDialog, onShowOccurrenceDialogChange), showOccurrenceDialog = _j[0], setShowOccurrenceDialog = _j[1], dispatchShowOccurrenceDialog = _j[2];
    var items = useSchedulerViewItemsContext()[0];
    var _k = useSchedulerViewFocusedItemsContext(), dispatchViewItemsFocus = _k[1];
    var _l = useSchedulerViewFocusedSlotsContext(), dispatchViewSlotsFocus = _l[1];
    var selected = Boolean(selectedItems && selectedItems.some(function (si) { return si.current === item.current; }));
    var state = React.useMemo(function () { return ({
        selected: selected,
        series: series,
        formItem: formItem,
        dragItem: dragItem,
        resizeItem: resizeItem,
        removeItem: removeItem,
        showRemoveDialog: showRemoveDialog,
        showOccurrenceDialog: showOccurrenceDialog
    }); }, [dragItem, formItem, removeItem, resizeItem, selected, series, showOccurrenceDialog, showRemoveDialog]);
    var actionsReducerMap = React.useMemo(function () {
        var _a;
        return (_a = {},
            _a[SERIES_ACTION.set] = dispatchSeries,
            _a[SERIES_ACTION.toggle] = dispatchSeries,
            _a[SERIES_ACTION.reset] = dispatchSeries,
            _a[ITEMS_SELECT_ACTION.select] = dispatchItemSelection,
            _a[ITEMS_SELECT_ACTION.add] = dispatchItemSelection,
            _a[ITEMS_SELECT_ACTION.remove] = dispatchItemSelection,
            _a[ITEMS_SELECT_ACTION.reset] = dispatchItemSelection,
            _a[ITEMS_SELECT_ACTION.selectNext] = dispatchItemSelection,
            _a[ITEMS_SELECT_ACTION.selectPrev] = dispatchItemSelection,
            _a[FORM_ITEM_ACTION.set] = dispatchFormItem,
            _a[FORM_ITEM_ACTION.setMaster] = dispatchFormItem,
            _a[FORM_ITEM_ACTION.reset] = dispatchFormItem,
            _a[FORM_ITEM_ACTION.complete] = dispatchFormItem,
            _a[REMOVE_ITEM_ACTION.set] = dispatchRemoveItem,
            _a[REMOVE_ITEM_ACTION.reset] = dispatchRemoveItem,
            _a[REMOVE_ITEM_ACTION.complete] = dispatchRemoveItem,
            _a[SHOW_OCCURRENCE_DIALOG_ACTION.close] = dispatchShowOccurrenceDialog,
            _a[SHOW_OCCURRENCE_DIALOG_ACTION.open] = dispatchShowOccurrenceDialog,
            _a[SHOW_OCCURRENCE_DIALOG_ACTION.set] = dispatchShowOccurrenceDialog,
            _a[SHOW_OCCURRENCE_DIALOG_ACTION.toggle] = dispatchShowOccurrenceDialog,
            _a[SHOW_OCCURRENCE_DIALOG_ACTION.reset] = dispatchShowOccurrenceDialog,
            _a[SHOW_REMOVE_DIALOG_ACTION.close] = dispatchShowRemoveDialog,
            _a[SHOW_REMOVE_DIALOG_ACTION.open] = dispatchShowRemoveDialog,
            _a[SHOW_REMOVE_DIALOG_ACTION.set] = dispatchShowRemoveDialog,
            _a[SHOW_REMOVE_DIALOG_ACTION.toggle] = dispatchShowRemoveDialog,
            _a[SHOW_REMOVE_DIALOG_ACTION.reset] = dispatchShowRemoveDialog,
            _a[DRAG_ITEM_ACTION.start] = dispatchDragItem,
            _a[DRAG_ITEM_ACTION.drag] = dispatchDragItem,
            _a[DRAG_ITEM_ACTION.complete] = dispatchDragItem,
            _a[DRAG_ITEM_ACTION.completeOccurrence] = dispatchDragItem,
            _a[DRAG_ITEM_ACTION.completeSeries] = dispatchDragItem,
            _a[DRAG_ITEM_ACTION.set] = dispatchDragItem,
            _a[DRAG_ITEM_ACTION.reset] = dispatchDragItem,
            _a[DRAG_ITEM_ACTION.dragSelected] = dispatchDragItem,
            _a[RESIZE_ITEM_ACTION.start] = dispatchResizeItem,
            _a[RESIZE_ITEM_ACTION.startDrag] = dispatchResizeItem,
            _a[RESIZE_ITEM_ACTION.startDragSelected] = dispatchResizeItem,
            _a[RESIZE_ITEM_ACTION.endDrag] = dispatchResizeItem,
            _a[RESIZE_ITEM_ACTION.endDragSelected] = dispatchResizeItem,
            _a[RESIZE_ITEM_ACTION.complete] = dispatchResizeItem,
            _a[RESIZE_ITEM_ACTION.completeOccurrence] = dispatchResizeItem,
            _a[RESIZE_ITEM_ACTION.completeSeries] = dispatchResizeItem,
            _a[RESIZE_ITEM_ACTION.set] = dispatchResizeItem,
            _a[RESIZE_ITEM_ACTION.reset] = dispatchResizeItem,
            _a[ITEMS_FOCUS_ACTION.next] = dispatchViewItemsFocus,
            _a[ITEMS_FOCUS_ACTION.prev] = dispatchViewItemsFocus,
            _a[SLOTS_FOCUS_ACTION.left] = dispatchViewSlotsFocus,
            _a[SLOTS_FOCUS_ACTION.right] = dispatchViewSlotsFocus,
            _a[SLOTS_FOCUS_ACTION.up] = dispatchViewSlotsFocus,
            _a[SLOTS_FOCUS_ACTION.down] = dispatchViewSlotsFocus,
            _a.null = function () { },
            _a);
    }, [
        dispatchDragItem,
        dispatchFormItem,
        dispatchItemSelection,
        dispatchRemoveItem,
        dispatchResizeItem,
        dispatchSeries,
        dispatchShowOccurrenceDialog,
        dispatchShowRemoveDialog,
        dispatchViewItemsFocus,
        dispatchViewSlotsFocus
    ]);
    var handleFocus = React.useCallback(function (event) {
        if (onFocusAction) {
            var actions = onFocusAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }));
            }
        }
        if (onFocus) {
            onFocus.call(undefined, event);
        }
    }, [actionsReducerMap, onFocus, onFocusAction, props, state]);
    var handleMouseDown = React.useCallback(function (event) {
        if (onMouseDownAction) {
            var actions = onMouseDownAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }));
            }
        }
        if (onMouseDown) {
            onMouseDown.call(undefined, event);
        }
    }, [actionsReducerMap, onMouseDown, onMouseDownAction, props, state]);
    var handleMouseUp = React.useCallback(function (event) {
        if (onMouseUpAction) {
            var actions = onMouseUpAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }));
            }
        }
        if (onMouseUp) {
            onMouseUp.call(undefined, event);
        }
    }, [actionsReducerMap, onMouseUp, onMouseUpAction, props, state]);
    var _m = React.useContext(SchedulerItemSelectionContext), setSelectedItem = _m[1];
    var handleClick = React.useCallback(function (event) {
        if (onClickAction) {
            setSelectedItem(item.current);
            var actions = onClickAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }));
            }
        }
        if (onClick) {
            onClick.call(undefined, event);
        }
    }, [actionsReducerMap, onClick, onClickAction, props, state]);
    var handleDoubleClick = React.useCallback(function (event) {
        if (onDoubleClickAction) {
            var actions = onDoubleClickAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }));
            }
        }
        if (onDoubleClick) {
            onDoubleClick.call(undefined, event);
        }
    }, [onDoubleClickAction, onDoubleClick, props, actionsReducerMap, state]);
    var handleRemoveClick = React.useCallback(function (event) {
        if (onRemoveClickAction) {
            var actions = onRemoveClickAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }));
            }
        }
        if (onRemoveClick) {
            onRemoveClick.call(undefined, event);
        }
    }, [onRemoveClickAction, onRemoveClick, props, actionsReducerMap, state]);
    var handlePress = React.useCallback(function (event) {
        if (onPressAction) {
            var actions = onPressAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event);
            }
        }
        if (onPress) {
            onPress.call(undefined, event);
        }
    }, [onPressAction, onPress, props, actionsReducerMap, state]);
    var handleDrag = React.useCallback(function (event) {
        if (onDragAction) {
            var actions = onDragAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event.dragEvent.originalEvent); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event.dragEvent.originalEvent);
            }
        }
        if (onDrag) {
            onDrag.call(undefined, event);
        }
    }, [onDragAction, onDrag, props, actionsReducerMap, state]);
    var handleRelease = React.useCallback(function (event) {
        if (onReleaseAction) {
            var actions = onReleaseAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event.dragEvent.originalEvent); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event.dragEvent.originalEvent);
            }
        }
        if (onRelease) {
            onRelease.call(undefined, event);
        }
    }, [onReleaseAction, onRelease, props, actionsReducerMap, state]);
    var handleResizePress = React.useCallback(function (event) {
        if (onResizePressAction) {
            var actions = onResizePressAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event.dragEvent.originalEvent); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event.dragEvent.originalEvent);
            }
        }
        if (onResizePress) {
            onResizePress.call(undefined, event);
        }
    }, [onResizePressAction, onResizePress, props, state, actionsReducerMap]);
    var handleResizeStartDrag = React.useCallback(function (event) {
        if (onResizeStartDragAction) {
            var actions = onResizeStartDragAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event.dragEvent.originalEvent); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event.dragEvent.originalEvent);
            }
        }
        if (onResizeStartDrag) {
            onResizeStartDrag.call(undefined, event);
        }
    }, [onResizeStartDrag, onResizeStartDragAction, props, actionsReducerMap, state]);
    var handleResizeEndDrag = React.useCallback(function (event) {
        if (onResizeEndDragAction) {
            var actions = onResizeEndDragAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event.dragEvent.originalEvent); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event.dragEvent.originalEvent);
            }
        }
        if (onResizeEndDrag) {
            onResizeEndDrag.call(undefined, event);
        }
    }, [onResizeEndDrag, onResizeEndDragAction, props, actionsReducerMap, state]);
    var handleResizeRelease = React.useCallback(function (event) {
        if (onResizeReleaseAction) {
            var actions = onResizeReleaseAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event.dragEvent.originalEvent); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event.dragEvent.originalEvent);
            }
        }
        if (onResizeRelease) {
            onResizeRelease.call(undefined, event);
        }
    }, [onResizeReleaseAction, onResizeRelease, props, actionsReducerMap, state]);
    var handleFormSubmit = React.useCallback(function (event) {
        if (onFormSubmitAction) {
            var actions = onFormSubmitAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event);
            }
        }
        if (onFormSubmit) {
            onFormSubmit.call(undefined, event);
        }
    }, [onFormSubmitAction, onFormSubmit, props, state, actionsReducerMap]);
    var handleCancel = React.useCallback(function (event) {
        if (onCancelAction) {
            var actions = onCancelAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event);
            }
        }
        if (onCancel) {
            onCancel.call(undefined, event);
        }
    }, [onCancelAction, onCancel, props, state, actionsReducerMap]);
    var handleOccurrenceClick = React.useCallback(function (event) {
        if (onOccurrenceClickAction) {
            var actions = onOccurrenceClickAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event);
            }
        }
        if (onOccurrenceClick) {
            onOccurrenceClick.call(undefined, event);
        }
    }, [onOccurrenceClickAction, onOccurrenceClick, props, state, actionsReducerMap]);
    var handleSeriesClick = React.useCallback(function (event) {
        if (onSeriesClickAction) {
            var actions = onSeriesClickAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event);
            }
        }
        if (onSeriesClick) {
            onSeriesClick.call(undefined, event);
        }
    }, [onSeriesClickAction, onSeriesClick, props, state, actionsReducerMap]);
    var handleKeyDown = React.useCallback(function (event) {
        if (onKeyDownAction) {
            var actions = onKeyDownAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event.syntheticEvent); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event.syntheticEvent);
            }
        }
        if (onKeyDown) {
            onKeyDown.call(undefined, event);
        }
    }, [onKeyDownAction, onKeyDown, props, state, actionsReducerMap]);
    var handleKeyUp = React.useCallback(function (event) {
        if (onKeyUpAction) {
            var actions = onKeyUpAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event.syntheticEvent); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event.syntheticEvent);
            }
        }
        if (onKeyUp) {
            onKeyUp.call(undefined, event);
        }
    }, [onKeyUpAction, onKeyUp, props, state, actionsReducerMap]);
    var handleRemoveConfirm = React.useCallback(function (event) {
        if (onRemoveConfirmAction) {
            var actions = onRemoveConfirmAction(event, props, state);
            if (actions) {
                Array.isArray(actions)
                    ? actions.filter(Boolean).map(function (action) { return action && actionsReducerMap[action.type](__assign(__assign({}, action), { item: item }), event.syntheticEvent); })
                    : actionsReducerMap[actions.type](__assign(__assign({}, actions), { item: item }), event.syntheticEvent);
            }
        }
        if (onRemoveConfirm) {
            onRemoveConfirm.call(undefined, event);
        }
    }, [onRemoveConfirmAction, onRemoveConfirm, props, state, actionsReducerMap]);
    React.useEffect(function () {
        var isFirst = items.length && items[0].current === item.current;
        setTabIndex(props.tabIndex !== undefined
            ? props.tabIndex === null
                ? undefined
                : props.tabIndex
            : selectedItems.length === 0
                ? isFirst
                    ? 0
                    : undefined
                : undefined);
    }, [items, props.tabIndex, selectedItems.length]);
    return (React.createElement(SchedulerEditItemContext, { props: props, form: [formItem, setFormItem, dispatchFormItem], drag: [dragItem, setDragItem, dispatchDragItem], resize: [resizeItem, setResizeItem, dispatchResizeItem], remove: [removeItem, setRemoveItem, dispatchRemoveItem], showRemoveDialog: [showRemoveDialog, setShowRemoveDialog, dispatchShowRemoveDialog], showOccurrenceDialog: [showOccurrenceDialog, setShowOccurrenceDialog, dispatchShowOccurrenceDialog] },
        React.createElement(ViewItem, __assign({}, props, { _ref: item, itemRef: item, selected: selected, tabIndex: tabIndex, id: eventId, 
            // Keyboard
            onKeyDown: handleKeyDown, onKeyUp: handleKeyUp, 
            // Focus
            onFocus: handleFocus, 
            // Mouse
            onMouseUp: handleMouseUp, onMouseDown: handleMouseDown, onClick: handleClick, onDoubleClick: handleDoubleClick, onRemoveClick: handleRemoveClick, 
            // Drag
            onPress: handlePress, onDrag: handleDrag, onRelease: handleRelease, 
            // Resize
            onResizePress: handleResizePress, onResizeEndDrag: handleResizeEndDrag, onResizeStartDrag: handleResizeStartDrag, onResizeRelease: handleResizeRelease })),
        ((dragItem && editable.drag)) && (Array.isArray(dragItem)
            ? dragItem.map(function (di, idx) { return (React.createElement(Drag, { key: idx, ignoreIsAllDay: ignoreIsAllDay, dataItem: di, vertical: props.vertical, viewItem: ViewItem, item: props.item })); })
            : (React.createElement(Drag, { ignoreIsAllDay: ignoreIsAllDay, dataItem: dragItem, vertical: props.vertical, viewItem: ViewItem, item: props.item }))),
        ((resizeItem && editable.resize)) && (Array.isArray(resizeItem)
            ? resizeItem.map(function (ri, idx) { return (React.createElement(Resize, { key: idx, format: props.format, ignoreIsAllDay: ignoreIsAllDay, dataItem: ri, viewItem: props.viewItem, item: props.item, vertical: props.vertical })); })
            : (React.createElement(Resize, { format: props.format, ignoreIsAllDay: ignoreIsAllDay, dataItem: resizeItem, viewItem: props.viewItem, item: props.item, vertical: props.vertical }))),
        (formItem && !showOccurrenceDialog && editable.edit) && (React.createElement(Form, { dataItem: formItem, onSubmit: handleFormSubmit, onClose: handleCancel, onCancel: handleCancel })),
        (showOccurrenceDialog) && (React.createElement(OccurrenceDialog, { dataItem: formItem || dragItem || resizeItem || removeItem, isRemove: removeItem !== null, onClose: handleCancel, onOccurrenceClick: handleOccurrenceClick, onSeriesClick: handleSeriesClick })),
        (showRemoveDialog && removeItem && editable.remove) && (React.createElement(RemoveDialog, { dataItem: removeItem, onClose: handleCancel, onCancel: handleCancel, onConfirm: handleRemoveConfirm }))));
});
var defaultProps = {
    viewItem: SchedulerViewItem,
    drag: SchedulerDrag,
    resize: SchedulerResize,
    form: SchedulerForm,
    occurrenceDialog: SchedulerOccurrenceDialog,
    removeDialog: SchedulerRemoveDialog,
    onClickAction: function (event, _, state) { return [
        { type: (event.syntheticEvent.metaKey || event.syntheticEvent.ctrlKey)
                ? (state.selected && !state.dragItem && !state.resizeItem)
                    ? ITEMS_SELECT_ACTION.remove
                    : ITEMS_SELECT_ACTION.add
                : ITEMS_SELECT_ACTION.select
        }
    ]; },
    onDoubleClickAction: function (_, props) { return props.editable
        ? [
            { type: FORM_ITEM_ACTION.set, payload: props.dataItem },
            (props.isRecurring) && { type: SHOW_OCCURRENCE_DIALOG_ACTION.open }
        ].filter(Boolean)
        : []; },
    onRemoveClickAction: function (_, props) { return props.editable
        ? [
            { type: REMOVE_ITEM_ACTION.set, payload: props.dataItem },
            props.isRecurring ? { type: SHOW_OCCURRENCE_DIALOG_ACTION.open } : { type: SHOW_REMOVE_DIALOG_ACTION.open }
        ]
        : []; },
    onPressAction: function (event, props) { return props.editable
        ? { type: DRAG_ITEM_ACTION.start, payload: { x: event.dragEvent.clientX, y: event.dragEvent.clientY } }
        : []; },
    onDragAction: function (event, props) { return props.editable
        ? {
            type: (event.dragEvent.originalEvent.metaKey || event.dragEvent.originalEvent.ctrlKey)
                ? DRAG_ITEM_ACTION.dragSelected
                : DRAG_ITEM_ACTION.drag,
            payload: { x: event.dragEvent.clientX, y: event.dragEvent.clientY }
        }
        : []; },
    onReleaseAction: function (event, props, state) { return (props.editable && state.dragItem)
        ? (props.isRecurring && !props.isException && state.series === null)
            ? { type: SHOW_OCCURRENCE_DIALOG_ACTION.open }
            : { type: props.isRecurring
                    ? state.series
                        ? DRAG_ITEM_ACTION.completeSeries
                        : DRAG_ITEM_ACTION.completeOccurrence
                    : DRAG_ITEM_ACTION.complete,
                payload: { x: event.dragEvent.clientX, y: event.dragEvent.clientY }
            }
        : []; },
    onResizePressAction: function (event, props) { return props.editable
        ? { type: RESIZE_ITEM_ACTION.start, payload: { x: event.dragEvent.clientX, y: event.dragEvent.clientY } }
        : []; },
    onResizeStartDragAction: function (event, props) { return props.editable
        ? {
            type: (event.dragEvent.originalEvent.metaKey || event.dragEvent.originalEvent.ctrlKey)
                ? RESIZE_ITEM_ACTION.startDragSelected
                : RESIZE_ITEM_ACTION.startDrag,
            payload: { x: event.dragEvent.clientX, y: event.dragEvent.clientY }
        }
        : []; },
    onResizeEndDragAction: function (event, props) { return props.editable
        ? {
            type: (event.dragEvent.originalEvent.metaKey || event.dragEvent.originalEvent.ctrlKey)
                ? RESIZE_ITEM_ACTION.endDragSelected
                : RESIZE_ITEM_ACTION.endDrag,
            payload: { x: event.dragEvent.clientX, y: event.dragEvent.clientY }
        }
        : []; },
    onResizeReleaseAction: function (event, props, state) { return (props.editable && state.resizeItem)
        ? (props.isRecurring && !props.isException && state.series === null)
            ? { type: SHOW_OCCURRENCE_DIALOG_ACTION.open }
            : { type: props.isRecurring
                    ? state.series
                        ? RESIZE_ITEM_ACTION.completeSeries
                        : RESIZE_ITEM_ACTION.completeOccurrence
                    : RESIZE_ITEM_ACTION.complete,
                payload: { x: event.dragEvent.clientX, y: event.dragEvent.clientY }
            }
        : []; },
    onOccurrenceClickAction: function (_event, props, state) {
        if (state.dragItem) {
            return [
                { type: DRAG_ITEM_ACTION.completeOccurrence },
                { type: SHOW_OCCURRENCE_DIALOG_ACTION.close }
            ];
        }
        if (state.resizeItem) {
            return [
                { type: RESIZE_ITEM_ACTION.completeOccurrence },
                { type: SHOW_OCCURRENCE_DIALOG_ACTION.close }
            ];
        }
        if (state.formItem) {
            return [
                { type: SERIES_ACTION.set, payload: false },
                { type: FORM_ITEM_ACTION.set, payload: props.dataItem },
                { type: SHOW_OCCURRENCE_DIALOG_ACTION.close }
            ];
        }
        if (state.removeItem) {
            return [
                { type: SERIES_ACTION.set, payload: false },
                { type: REMOVE_ITEM_ACTION.set, payload: props.dataItem },
                { type: SHOW_REMOVE_DIALOG_ACTION.open },
                { type: SHOW_OCCURRENCE_DIALOG_ACTION.close }
            ];
        }
    },
    onSeriesClickAction: function (_event, props, state) {
        if (state.dragItem) {
            return [
                { type: DRAG_ITEM_ACTION.completeSeries },
                { type: SHOW_OCCURRENCE_DIALOG_ACTION.close }
            ];
        }
        if (state.resizeItem) {
            return [
                { type: RESIZE_ITEM_ACTION.completeSeries },
                { type: SHOW_OCCURRENCE_DIALOG_ACTION.close }
            ];
        }
        if (state.formItem) {
            return [
                { type: SERIES_ACTION.set, payload: true },
                { type: FORM_ITEM_ACTION.setMaster, payload: props.dataItem },
                { type: SHOW_OCCURRENCE_DIALOG_ACTION.close }
            ];
        }
        if (state.removeItem) {
            return [
                { type: SERIES_ACTION.set, payload: true },
                { type: REMOVE_ITEM_ACTION.set, payload: props.dataItem },
                { type: SHOW_REMOVE_DIALOG_ACTION.open },
                { type: SHOW_OCCURRENCE_DIALOG_ACTION.close }
            ];
        }
    },
    onKeyDownAction: function (event, props) {
        switch (event.syntheticEvent.keyCode) {
            case Keys.enter:
                return [
                    { type: FORM_ITEM_ACTION.set, payload: props.dataItem },
                    (props.isRecurring) && { type: SHOW_OCCURRENCE_DIALOG_ACTION.open }
                ];
            case Keys.tab:
                return [
                    { type: event.syntheticEvent.shiftKey ? ITEMS_FOCUS_ACTION.prev : ITEMS_FOCUS_ACTION.next, ignoreIsAllDay: props.ignoreIsAllDay },
                    { type: event.syntheticEvent.shiftKey ? ITEMS_SELECT_ACTION.selectPrev : ITEMS_SELECT_ACTION.selectNext, ignoreIsAllDay: props.ignoreIsAllDay }
                ];
            case Keys.up:
                return [
                    Boolean(props.slots.length && props.slots[0]._ref.current) && { type: SLOTS_FOCUS_ACTION.up, slot: props.slots[0]._ref }
                ];
            case Keys.right:
                return [
                    Boolean(props.slots.length && props.slots[0]._ref.current) && { type: SLOTS_FOCUS_ACTION.right, slot: props.slots[0]._ref }
                ];
            case Keys.down:
                return [
                    Boolean(props.slots.length && props.slots[props.slots.length - 1]._ref.current) && { type: SLOTS_FOCUS_ACTION.down, slot: props.slots[props.slots.length - 1]._ref }
                ];
            case Keys.left:
                return [
                    Boolean(props.slots.length && props.slots[0]._ref.current) && { type: SLOTS_FOCUS_ACTION.left, slot: props.slots[0]._ref }
                ];
            default:
                return;
        }
    },
    onFormSubmitAction: function (event) { return ({ type: FORM_ITEM_ACTION.complete, payload: event.value }); },
    onRemoveConfirmAction: function () { return [
        { type: REMOVE_ITEM_ACTION.complete },
        { type: SHOW_OCCURRENCE_DIALOG_ACTION.close }
    ]; },
    onCancelAction: function () { return [
        { type: SERIES_ACTION.reset },
        { type: REMOVE_ITEM_ACTION.reset },
        { type: FORM_ITEM_ACTION.reset },
        { type: DRAG_ITEM_ACTION.reset },
        { type: RESIZE_ITEM_ACTION.reset },
        { type: SHOW_REMOVE_DIALOG_ACTION.reset },
        { type: SHOW_OCCURRENCE_DIALOG_ACTION.reset }
    ]; }
};
SchedulerEditItem.defaultProps = defaultProps;
SchedulerEditItem.displayName = 'KendoReactSchedulerEditItem';
