var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import * as React from 'react';
import { findNextItem } from '../utils';
/**
 * Represents the available `action` types for the `SchedulerItemsSelectAction` objects.
 *
 * The available types are:
 * - 'ITEMS_SELECT_SELECT`
 * - 'ITEMS_SELECT_SELECT_NEXT`
 * - 'ITEMS_SELECT_SELECT_PREV`
 * - 'ITEMS_SELECT_RESET`
 * - 'ITEMS_SELECT_ADD`
 * - 'ITEMS_SELECT_REMOVE`
 */
export var ITEMS_SELECT_ACTION;
(function (ITEMS_SELECT_ACTION) {
    ITEMS_SELECT_ACTION["select"] = "ITEMS_SELECT_SELECT";
    ITEMS_SELECT_ACTION["selectNext"] = "ITEMS_SELECT_SELECT_NEXT";
    ITEMS_SELECT_ACTION["selectPrev"] = "ITEMS_SELECT_SELECT_PREV";
    ITEMS_SELECT_ACTION["reset"] = "ITEMS_SELECT_RESET";
    ITEMS_SELECT_ACTION["add"] = "ITEMS_SELECT_ADD";
    ITEMS_SELECT_ACTION["remove"] = "ITEMS_SELECT_REMOVE";
})(ITEMS_SELECT_ACTION || (ITEMS_SELECT_ACTION = {}));
/** @hidden */
export var useItemsSelection = function (items) {
    var _a = React.useState([]), selectedItems = _a[0], setSelectedItems = _a[1];
    var handleSchedulerItemsSelectAction = React.useCallback(function (action, event) {
        switch (action.type) {
            case ITEMS_SELECT_ACTION.select:
                if (!action.item) {
                    return;
                }
                setSelectedItems([action.item]);
                break;
            case ITEMS_SELECT_ACTION.selectNext: {
                if (!action.item || !action.item.current || !items) {
                    return;
                }
                var next = findNextItem(action.item, items, action.ignoreIsAllDay, false);
                if (next) {
                    event.preventDefault();
                    setSelectedItems([next]);
                }
                break;
            }
            case ITEMS_SELECT_ACTION.selectPrev: {
                if (!action.item || !action.item.current || !items) {
                    return;
                }
                var next = findNextItem(action.item, items, action.ignoreIsAllDay, true);
                if (next) {
                    event.preventDefault();
                    setSelectedItems([next]);
                }
                break;
            }
            case ITEMS_SELECT_ACTION.reset:
                setSelectedItems([]);
                break;
            case ITEMS_SELECT_ACTION.add:
                if (!action.item) {
                    return;
                }
                if (!selectedItems.some(function (si) { return si === action.item; })) {
                    setSelectedItems(__spreadArray(__spreadArray([], selectedItems, true), [action.item], false));
                }
                break;
            case ITEMS_SELECT_ACTION.remove:
                if (!action.item) {
                    return;
                }
                setSelectedItems(__spreadArray([], selectedItems.filter(function (si) { return si !== action.item; }), true));
                break;
            default:
                break;
        }
    }, [items, selectedItems]);
    return [selectedItems, handleSchedulerItemsSelectAction];
};
