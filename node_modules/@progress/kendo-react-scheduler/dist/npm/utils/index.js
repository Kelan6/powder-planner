"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.orderSort = exports.findNextItem = exports.findFirstItem = exports.noop = exports.mapItemsToSlots = exports.mapSlotsToItems = exports.calculateOrder = exports.findMissing = exports.shallowCompare = exports.extractResources = exports.extractResourceFields = exports.extractGroups = exports.setTime = exports.isNullOrEmptyString = exports.isBlank = exports.generateResourceFields = exports.toSchedulerResources = exports.toSchedulerGroups = exports.isInDaysRange = exports.isInTimeRange = exports.getModelFields = exports.defaultModelFields = exports.roundAllDayEnd = exports.intersects = exports.isException = exports.buildException = exports.isMaster = exports.findMaster = exports.groupResources = exports.isRecurring = exports.isRecurringException = exports.toInvariantTime = exports.toUTCDateTime = exports.getUTCDate = exports.toUTCDate = exports.isRecurringMaster = exports.isPresent = exports.assignFields = exports.assignField = exports.setField = exports.getField = exports.slotDive = exports.getToday = exports.dateWithTime = exports.addUTCDays = exports.formatEventTime = exports.isGroupped = exports.isMultiDay = exports.last = exports.first = void 0;
var kendo_date_math_1 = require("@progress/kendo-date-math");
var utils_1 = require("../views/common/utils");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var constants_1 = require("../constants");
var kendo_data_query_1 = require("@progress/kendo-data-query");
/** @hidden */
var first = function (arr) { return arr[0]; };
exports.first = first;
/** @hidden */
var last = function (arr) { return arr[arr.length - 1]; };
exports.last = last;
/** @hidden */
var isMultiDay = function (item) {
    var result = (item.end.getTime() - item.start.getTime()) > new Date(0).setHours(24);
    return result;
};
exports.isMultiDay = isMultiDay;
/** @hidden */
var isGroupped = function (resources) {
    var set = new Set();
    resources.forEach(function (resource) {
        set.add(resource.field);
    });
    return set.size === resources.length;
};
exports.isGroupped = isGroupped;
/**
 * @hidden
 */
function formatEventTime(intl, start, end, isAllDay) {
    var startTimeFormat = { skeleton: 'yMMMMEEEEdhm' };
    var startDateFormat = { skeleton: 'yMMMMEEEEd' };
    var endFormat = 't';
    return isAllDay ?
        "".concat(intl.formatDate(start, startDateFormat)) :
        "".concat(intl.formatDate(start, startTimeFormat), "\u2013").concat(intl.formatDate(end, endFormat));
}
exports.formatEventTime = formatEventTime;
/**
 * @hidden
 * TODO Move to date-math
 */
var addUTCDays = function (date, offset) {
    var newDate = new Date(date.getTime());
    newDate.setUTCDate(newDate.getUTCDate() + offset);
    return newDate;
};
exports.addUTCDays = addUTCDays;
/** @hidden */
function dateWithTime(target, time) {
    return new Date(target.getFullYear(), target.getMonth(), target.getDate(), time.getHours(), time.getMinutes());
}
exports.dateWithTime = dateWithTime;
/**
 * @hidden
 */
var getToday = function () { return (0, kendo_date_math_1.getDate)(new Date()); };
exports.getToday = getToday;
// Introduce max depth doe to Maximum call stack size exceeded when react <body />
// The element.closest() approach is not available due to browser support issues.
/** @hidden */
var slotDive = function (x, y, maxDepth, level) {
    if (level === void 0) { level = 0; }
    if (level === maxDepth) {
        return null;
    }
    var result = null;
    var element = document.elementFromPoint(x, y);
    if (!element) {
        return result;
    }
    var isSlot = element.getAttribute('data-slot') === 'true';
    if (isSlot) {
        return element;
    }
    else {
        var oldPointerEvents = element.style.pointerEvents;
        element.style.pointerEvents = 'none';
        result = (0, exports.slotDive)(x, y, maxDepth, level + 1);
        element.style.pointerEvents = oldPointerEvents;
    }
    return result;
};
exports.slotDive = slotDive;
/**
 * @hidden
 */
var getField = function (obj, field) { return (0, kendo_react_common_1.getter)(field)(obj); };
exports.getField = getField;
/**
 * @hidden
 */
var setField = function (obj, field, value) {
    if (!field) {
        return;
    }
    return (0, kendo_react_common_1.setter)(field)(obj, value);
};
exports.setField = setField;
/**
 * @hidden
 */
function assignField(target, source, field) {
    (0, exports.setField)(target, field, (0, exports.getField)(source, field));
}
exports.assignField = assignField;
/**
 * @hidden
 */
function assignFields(target, source) {
    var fields = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        fields[_i - 2] = arguments[_i];
    }
    for (var idx = 0; idx < fields.length; idx++) {
        assignField(target, source, fields[idx]);
    }
}
exports.assignFields = assignFields;
/**
 * @hidden
 */
var isPresent = function (value) { return value !== null && value !== undefined; };
exports.isPresent = isPresent;
/**
 * @hidden
 */
var isRecurringMaster = function (event) { return event.recurrenceRule && !(0, exports.isPresent)(event.recurrenceId); };
exports.isRecurringMaster = isRecurringMaster;
//  TODO: move to date-math
/** @hidden */
function toUTCDate(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate()));
}
exports.toUTCDate = toUTCDate;
// TODO: move to date-math
/** @hidden */
function getUTCDate(utcDate) {
    return new Date(Date.UTC(utcDate.getUTCFullYear(), utcDate.getUTCMonth(), utcDate.getUTCDate()));
}
exports.getUTCDate = getUTCDate;
// TODO: move to date-math
/** @hidden */
function toUTCDateTime(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));
}
exports.toUTCDateTime = toUTCDateTime;
/** @hidden */
function toInvariantTime(date) {
    var staticDate = new Date(1980, 1, 1, 0, 0, 0);
    if (date) {
        staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
    }
    return staticDate;
}
exports.toInvariantTime = toInvariantTime;
/** @hidden */
function isRecurringException(event) {
    return event && (0, exports.isPresent)(event.recurrenceId) && !event.recurrenceRule;
}
exports.isRecurringException = isRecurringException;
/**
 * @hidden
 */
var isRecurring = function (event, fields) {
    var recurrenceId = (0, kendo_react_common_1.getter)(fields.recurrenceId || 'recurrenceId')(event);
    var recurrenceRule = (0, kendo_react_common_1.getter)(fields.recurrenceRule || 'recurrenceRule')(event);
    return !!(recurrenceRule || recurrenceId);
};
exports.isRecurring = isRecurring;
/**
 * @hidden
 */
var groupResources = function (group, resources) {
    var result = [];
    if (group && group.resources && group.resources.length) {
        var groups_1 = group.resources;
        var _loop_1 = function (idx) {
            var resource = resources.find(function (r) { return r.name === groups_1[idx]; });
            result.push(resource);
        };
        for (var idx = 0; idx < groups_1.length; idx++) {
            _loop_1(idx);
        }
    }
    return result;
};
exports.groupResources = groupResources;
/**
 * @hidden
 */
var findMaster = function (event, fields, data) {
    var headId = (0, exports.isMaster)(event, fields) ? (0, exports.getField)(event, fields.id) : (0, exports.getField)(event, fields.recurrenceId);
    return data.find(function (currentEvent) { return (0, exports.getField)(currentEvent, fields.id) === headId; });
};
exports.findMaster = findMaster;
/**
 * @hidden
 */
var isMaster = function (event, fields) {
    var id = (0, exports.getField)(event, fields.id);
    var recurrenceId = (0, exports.getField)(event, fields.recurrenceId);
    var recurrenceRule = (0, exports.getField)(event, fields.recurrenceRule);
    return !!(id && recurrenceRule && (recurrenceId === undefined || recurrenceId === null));
};
exports.isMaster = isMaster;
/**
 * @hidden
 */
var buildException = function (event, fields, data) {
    var headEvent = (0, exports.findMaster)(event, fields, data);
    var copy = (0, kendo_react_common_1.clone)(event);
    assignField(copy, headEvent, fields.id);
    if (fields.id !== undefined) {
        (0, exports.setField)(copy, fields.id, constants_1.DEFAULT_ID);
    }
    if (fields.recurrenceRule !== undefined) {
        (0, exports.setField)(copy, fields.recurrenceRule, undefined);
    }
    if (fields.recurrenceId !== undefined) {
        (0, exports.setField)(copy, fields.recurrenceId, (0, exports.getField)(headEvent, fields.id));
    }
    return copy;
};
exports.buildException = buildException;
/**
 * @hidden
 */
var isException = function (event, fields) {
    return (0, exports.isPresent)((0, exports.getField)(event, fields.recurrenceId)) && !(0, exports.getField)(event, fields.recurrenceRule);
};
exports.isException = isException;
var maxDate = function (x, y) { return Math.max(x.getTime(), y.getTime()); };
var minDate = function (x, y) { return Math.min(x.getTime(), y.getTime()); };
/** @hidden */
var intersects = function (startTime, endTime, periodStart, periodEnd, inclusive) {
    if (inclusive === void 0) { inclusive = false; }
    return inclusive
        ? maxDate(endTime, periodEnd) - minDate(startTime, periodStart) <=
            (endTime.getTime() - startTime.getTime()) + (periodEnd.getTime() - periodStart.getTime())
        : maxDate(endTime, periodEnd) - minDate(startTime, periodStart) <
            (endTime.getTime() - startTime.getTime()) + (periodEnd.getTime() - periodStart.getTime());
};
exports.intersects = intersects;
/** @hidden */
var roundAllDayEnd = function (_a) {
    var start = _a.start, end = _a.end;
    var startDate = start.stripTime();
    var endDate = end.stripTime();
    return endDate.getTime() !== end.getTime() || startDate.getTime() === endDate.getTime() ? endDate.addDays(1) : endDate;
};
exports.roundAllDayEnd = roundAllDayEnd;
/**
 * @hidden
 */
exports.defaultModelFields = {
    id: 'id',
    start: 'start',
    startTimezone: 'startTimezone',
    originalStart: 'originalStart',
    end: 'end',
    endTimezone: 'endTimezone',
    isAllDay: 'isAllDay',
    title: 'title',
    description: 'description',
    recurrenceRule: 'recurrenceRule',
    recurrenceId: 'recurrenceId',
    recurrenceExceptions: 'recurrenceExceptions'
};
/** @hidden */
var getModelFields = function (modelFields) {
    return { fields: __assign(__assign({}, exports.defaultModelFields), modelFields) };
};
exports.getModelFields = getModelFields;
/** @hidden */
var isInTimeRange = function (date, min, max) {
    return ((min.getHours() < date.getHours()) || (min.getHours() === date.getHours() && min.getMinutes() <= date.getMinutes()))
        && ((date.getHours() < max.getHours()) || (max.getHours() === date.getHours() && date.getMinutes() < max.getMinutes()));
};
exports.isInTimeRange = isInTimeRange;
/** @hidden */
var isInDaysRange = function (date, min, max) {
    return min < max
        ? (min <= date && date <= max)
        : (date <= max || min <= date);
};
exports.isInDaysRange = isInDaysRange;
// /** @hidden */
// export const generateGroups = (
//     groupIndex: string | null,
//     nextGroupIndex: string | null,
//     groups: any[],
//     group: SchedulerGroup | undefined,
//     resources: SchedulerResource[] = []
// ) => {
//     if (!groupIndex || !nextGroupIndex) { return []; }
//     const groupedResources = toGroupResources(group, resources);
//     const flat = toFlatGroupResources(groupedResources);
//     return groups.map(g => g.index === Number(groupIndex)
//         ? { index: Number((nextGroupIndex)), resources: flat[Number(nextGroupIndex)] }
//         : g);
// };
/** @hidden */
var toSchedulerGroups = function (group, resources) {
    var groupedResources = (0, utils_1.toGroupResources)(group, resources);
    var flat = (0, utils_1.toFlatGroupResources)(groupedResources);
    if (flat.length === 1) {
        return [{
                index: 0,
                // resources: []
                resources: (resources || [])
                    .reduce(function (all, res) { return __spreadArray(__spreadArray([], all, true), res.data
                    .map(function (item) { return (__assign(__assign({}, item), { field: res.field, valueField: res.valueField, colorField: res.colorField, multiple: res.multiple })); }), true); }, [])
            }];
    }
    else {
        return flat.map(function (res, index) { return ({
            index: index,
            resources: res
        }); });
    }
};
exports.toSchedulerGroups = toSchedulerGroups;
/** @hidden */
var toSchedulerResources = function (resources) {
    if (resources === void 0) { resources = []; }
    return resources.reduce(function (all, res) { return __spreadArray(__spreadArray([], all, true), res.data.map(function (item) { return (__assign(__assign({}, item), { field: res.field, valueField: res.valueField, colorField: res.colorField, multiple: res.multiple })); }), true); }, []);
};
exports.toSchedulerResources = toSchedulerResources;
/** @hidden */
var generateResourceFields = function (groups, defaultFields) {
    if (!groups || !groups.length) {
        return defaultFields;
    }
    var result = {};
    groups.forEach(function (group) {
        group.resources.forEach(function (resource) {
            if (result[resource.field] === undefined) {
                result[resource.field] = resource[resource.valueField];
            }
        });
    });
    return result;
};
exports.generateResourceFields = generateResourceFields;
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
var isBlank = function (value) { return value === null || value === undefined; };
exports.isBlank = isBlank;
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
var isNullOrEmptyString = function (value) { return (0, exports.isBlank)(value) || (value.trim && value.trim().length === 0); };
exports.isNullOrEmptyString = isNullOrEmptyString;
/**
 * @hidden
 */
var setTime = function (origin, candidate) {
    var date = (0, kendo_date_math_1.cloneDate)(origin);
    date.setHours(candidate.getHours(), candidate.getMinutes(), candidate.getSeconds(), candidate.getMilliseconds());
    return date;
};
exports.setTime = setTime;
function getDataIdx(value, resource) {
    var data = resource.data;
    for (var dataIdx = 0; dataIdx < data.length; dataIdx++) {
        if ((0, exports.getField)(data[dataIdx], resource.valueField) === value) {
            return dataIdx;
        }
    }
    return 0;
}
/** @hidden */
var extractGroups = function (dataItem, fields, group, resources) {
    var groupedResources = (0, utils_1.toGroupResources)(group, resources);
    var flat = (0, utils_1.toFlatGroupResources)(groupedResources);
    var flatGroupsReducer = function (acc, items, index) {
        var match = true;
        items.forEach(function (item) {
            var expected = item[item.valueField];
            var actual = dataItem[fields[item.field] || item.field];
            if (Array.isArray(actual)) {
                match = match && actual.indexOf(expected) >= 0;
            }
            else {
                match = match && actual === expected;
            }
        });
        if (match) {
            return __spreadArray(__spreadArray([], acc, true), [{ index: index, resources: items }], false);
        }
        else {
            return acc;
        }
    };
    return flat.reduce(flatGroupsReducer, []);
};
exports.extractGroups = extractGroups;
var findLeafResource = function (level) {
    if (level === void 0) { level = 0; }
    return findLeafResource(level + 1);
};
/** @hidden */
var extractResourceFields = function (dataItem, fields, resources) {
    var result = {};
    if (!resources || !resources.length) {
        return result;
    }
    resources.forEach(function (resource) {
        var match = resource.data.find(function (item) { return item.value === dataItem[fields[resource.field] || resource.field]; });
        if (match) {
            result[resource.field] = match.value;
        }
    });
    return result;
};
exports.extractResourceFields = extractResourceFields;
/** @hidden */
var extractResources = function (dataItem, fields, resources) {
    if (resources === void 0) { resources = []; }
    var resourceIndex = 0;
    var itemResources = [];
    for (var resourceIdx = 0; resourceIdx < resources.length; resourceIdx++) {
        var resource = resources[resourceIdx];
        var values = (0, exports.getField)(dataItem, fields[resource.field] || resource.field);
        if (!Array.isArray(values)) {
            values = [values];
        }
        for (var valueIndex = 0; valueIndex < values.length; valueIndex++) {
            if (values[valueIndex] !== undefined) {
                var dataIdx = getDataIdx(values[valueIndex], resource);
                var data = resource.data[dataIdx];
                var itemResource = {
                    text: (0, exports.getField)(data, resource.textField),
                    color: (0, exports.getField)(data, resource.colorField),
                    value: (0, exports.getField)(data, resource.valueField)
                };
                itemResources.push(__assign(__assign({}, itemResource), { index: resourceIndex }));
            }
            resourceIndex++;
        }
    }
    return itemResources;
};
exports.extractResources = extractResources;
// Change from JSON.stringify to recursive compare! use clone
/** @hidden */
var shallowCompare = function (x, y) { return JSON.stringify(x) === JSON.stringify(y); };
exports.shallowCompare = shallowCompare;
/** @hidden */
var findMissing = function (orderNumbers) {
    var result = 0;
    var numbers = orderNumbers.slice();
    // Array.find is also O(n)
    numbers.sort(function (a, b) { return a - b; }).forEach(function (_, index) {
        if (numbers[index] === index) {
            result = index + 1;
        }
    });
    return result;
};
exports.findMissing = findMissing;
/** @hidden */
var calculateOrder = function (current, items, slots, ignoreIsAllDay) {
    if (ignoreIsAllDay === void 0) { ignoreIsAllDay = false; }
    var result;
    slots.forEach(function (slot) {
        var orderNumbers = [];
        var sorted = items.sort(function (a, b) { return a.props.start.getTime() - b.props.start.getTime(); });
        sorted.forEach(function (item) {
            var fit = (ignoreIsAllDay || (item.props.isAllDay === slot.current.props.isAllDay))
                && item.props.range.index === slot.current.props.range.index
                && item.props.group.index === slot.current.props.group.index
                && (0, exports.intersects)(item.props.start, item.props.end, slot.current.props.start, slot.current.props.end);
            if (fit) {
                var order = (0, exports.findMissing)(orderNumbers);
                if (item === current && result === undefined) {
                    result = order;
                }
                orderNumbers.splice(order, 0, order);
            }
        });
    });
    return result;
};
exports.calculateOrder = calculateOrder;
// TODO: REVISIT
/** @hidden */
var mapSlotsToItems = function (items, slots, ignoreIsAllDay) {
    if (ignoreIsAllDay === void 0) { ignoreIsAllDay = false; }
    // Clear
    slots.forEach(function (slot) { return slot.items.splice(0, slot.items.length); });
    // Populate
    slots.forEach(function (slot) {
        var orderNumbers = [];
        items.forEach(function (item) {
            var fit = (ignoreIsAllDay || (item.isAllDay === slot.isAllDay))
                && item.range.index === slot.range.index
                && item.group.index === slot.group.index
                && (0, exports.intersects)(item.start, item.end, slot.start, slot.end);
            if (fit) {
                var order = (0, exports.findMissing)(orderNumbers);
                if (item.order === null || item.order === undefined || item.order < order) {
                    item.order = order;
                }
                orderNumbers.splice(item.order, 0, item.order);
                slot.items.push(item);
            }
        });
    });
};
exports.mapSlotsToItems = mapSlotsToItems;
// TODO: REVISIT
/** @hidden */
var mapItemsToSlots = function (items, slots, ignoreIsAllDay) {
    if (ignoreIsAllDay === void 0) { ignoreIsAllDay = false; }
    // Clear
    items.forEach(function (item) { return item.slots.splice(0, item.slots.length); });
    // Populate
    items.forEach(function (item) {
        slots.forEach(function (slot) {
            var fit = (ignoreIsAllDay || (item.isAllDay === slot.isAllDay))
                && item.range.index === slot.range.index
                && item.group.index === slot.group.index
                && (0, exports.intersects)(item.start, item.end, slot.start, slot.end);
            if (fit) {
                item.slots.push(slot);
            }
        });
    });
};
exports.mapItemsToSlots = mapItemsToSlots;
/** @hidden */
var noop = function () {
    var _args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        _args[_i] = arguments[_i];
    }
};
exports.noop = noop;
/** @hidden */
var findFirstItem = function (current) {
    var next = current.props.items.find(function (i) { return i.order === 0; }) || current.props.items[0];
    return next && next._ref.current;
};
exports.findFirstItem = findFirstItem;
/** @hidden */
var findNextItem = function (ref, all, ignoreIsAllDay, backwards) {
    if (ignoreIsAllDay === void 0) { ignoreIsAllDay = false; }
    if (backwards === void 0) { backwards = false; }
    var current = ref.current;
    if (!current || !all) {
        return null;
    }
    var filtered = all.filter(function (i) { return i.current !== null && i.current.element !== null; });
    var sorted = (0, kendo_data_query_1.orderBy)(filtered, [
        { field: 'current.props.group.index', dir: 'asc' },
        { field: 'current.props.range.index', dir: 'asc' },
        (ignoreIsAllDay ? { field: '' } : { field: 'current.props.isAllDay', dir: 'desc' }),
        { field: 'current.props.start', dir: 'asc' }
    ]);
    var currentIndex = sorted
        .findIndex(function (i) { return i.current !== null && Boolean(i.current.props.uid === current.props.uid
        && ((i.current.props.occurrenceId === undefined) || i.current.props.occurrenceId === current.props.occurrenceId)
        && (i.current.props.group.index === current.props.group.index)
        && (i.current.props.range.index === current.props.range.index)
        && (ignoreIsAllDay || i.current.props.isAllDay === current.props.isAllDay)); });
    var next = sorted[currentIndex + (backwards ? -1 : 1)];
    return next;
};
exports.findNextItem = findNextItem;
/**
 * @hidden
 */
var orderSort = function (a, b) {
    return (a.order || 0) - (b.order || 0);
};
exports.orderSort = orderSort;
