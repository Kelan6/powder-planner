"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSlotExpand = void 0;
var React = require("react");
var utils_1 = require("../views/common/utils");
var constants_1 = require("../constants");
var context_1 = require("../context");
/** @hidden */
var useSlotExpand = function (slot, config) {
    var timeout = React.useRef();
    var initialHeight = React.useRef(0);
    var scheduler = (0, context_1.useSchedulerElementContext)();
    var getInitialHeight = function () {
        if (!slot.current) {
            return;
        }
        var element = slot.current.element;
        if (!element) {
            return;
        }
        initialHeight.current = element.clientHeight;
    };
    var expand = React.useCallback(function () {
        if (!config || !slot.current) {
            return;
        }
        var element = slot.current.element;
        var props = slot.current.props;
        if (!element) {
            return;
        }
        var slotPadding = (0, utils_1.getPadding)(element);
        var highest = 0;
        var existing = props.items.filter(function (i) {
            return i._ref.current;
        });
        existing.forEach(function (item) {
            if (!item._ref.current) {
                return;
            }
            var height = (0, utils_1.getRect)(item._ref.current.element).height;
            highest += height;
        });
        var minHeight = ((existing.length * constants_1.BORDER_WIDTH * 2)
            + highest
            - (slotPadding || 0)
            + (typeof config === 'object' && config.offsetTop ? config.offsetTop : 0)
            + (typeof config === 'object' && config.offsetBottom ? config.offsetBottom : 0));
        if (existing.length) {
            if (minHeight > (initialHeight.current - slotPadding)) {
                (0, utils_1.setRect)(element, { height: minHeight }, true);
            }
        }
        else if (element) {
            element.style.minHeight = '';
        }
    }, [config, slot]);
    var handleResize = React.useCallback(function () {
        if (timeout.current !== undefined) {
            window.cancelAnimationFrame(timeout.current);
        }
        timeout.current = window.requestAnimationFrame(function () {
            expand();
        });
    }, [expand]);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    React.useLayoutEffect(getInitialHeight, []);
    // eslint-disable-next-line react-hooks/exhaustive-deps
    React.useEffect(expand, [slot, slot.current && slot.current.props, config]);
    React.useEffect(function () {
        if (!slot.current) {
            return;
        }
        var props = slot.current.props;
        var existing = props.items.filter(function (i) {
            return i._ref.current;
        });
        var callbacks = existing.map(function (item) {
            if (!item._ref.current || !item._ref.current.element) {
                return;
            }
            if (!scheduler.current) {
                return;
            }
            var observer = new window.ResizeObserver(handleResize);
            observer.observe(item._ref.current.element);
            return function () {
                observer.disconnect();
            };
        });
        return function () {
            callbacks.forEach(function (cb) { return cb && cb(); });
        };
    }, [handleResize, scheduler, slot]);
};
exports.useSlotExpand = useSlotExpand;
