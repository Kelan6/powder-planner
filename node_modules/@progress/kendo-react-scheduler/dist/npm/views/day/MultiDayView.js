"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultProps = exports.MultiDayView = void 0;
var React = require("react");
var PropTypes = require("prop-types");
var kendo_date_math_1 = require("@progress/kendo-date-math");
var BaseView_1 = require("../../components/BaseView");
var HorizontalResourceIterator_1 = require("../common/HorizontalResourceIterator");
var DayViewGroupRowContent_1 = require("./DayViewGroupRowContent");
var VerticalResourceIterator_1 = require("../common/VerticalResourceIterator");
var DayViewAllDayRowContent_1 = require("./DayViewAllDayRowContent");
var DayViewRowContent_1 = require("./DayViewRowContent");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var utils_1 = require("../../utils");
var kendo_react_intl_1 = require("@progress/kendo-react-intl");
var constants_1 = require("../../constants");
var services_1 = require("../../services/");
var SchedulerEditSlot_1 = require("../../slots/SchedulerEditSlot");
var SchedulerEditItem_1 = require("../../items/SchedulerEditItem");
var SchedulerContext_1 = require("../../context/SchedulerContext");
var SchedulerResourceIteratorContext_1 = require("../../context/SchedulerResourceIteratorContext");
var CurrentTimeMarket_1 = require("../../components/CurrentTimeMarket");
var DateHeaderCell_1 = require("../../components/DateHeaderCell");
var FIRST_INDEX = 0;
var GRID_OFFSET = 1;
var EMPTY_CELL = React.createElement("div", { className: "k-scheduler-cell k-side-cell" });
/**
 * @hidden
 */
var MultiDayView = function (props) {
    var _a = (0, SchedulerContext_1.useSchedulerPropsContext)(), group = _a.group, timezone = _a.timezone, propResources = _a.resources;
    var intl = (0, kendo_react_intl_1.useInternationalization)();
    var EditItem = props.editItem || SchedulerEditItem_1.SchedulerEditItem;
    var EditSlot = props.editSlot || SchedulerEditSlot_1.SchedulerEditSlot;
    var showWorkHours = props.showWorkHours;
    var numberOfDays = props.numberOfDays || exports.defaultProps.numberOfDays;
    var slotDivisions = props.slotDivisions || exports.defaultProps.slotDivisions;
    var slotDuration = props.slotDuration || exports.defaultProps.slotDuration;
    var workWeekStart = props.workWeekStart || exports.defaultProps.workWeekStart;
    var workWeekEnd = props.workWeekEnd || exports.defaultProps.workWeekEnd;
    var workDayStart = intl.parseDate(props.workDayStart || props.isWorkDayStart || exports.defaultProps.isWorkDayStart);
    var workDayEnd = intl.parseDate(props.workDayEnd || props.isWorkDayEnd || exports.defaultProps.isWorkDayEnd);
    var startTime = intl.parseDate(props.startTime || exports.defaultProps.startTime);
    var endTime = intl.parseDate(props.endTime || exports.defaultProps.endTime);
    var data = (0, SchedulerContext_1.useSchedulerDataContext)()[0];
    var groups = (0, SchedulerContext_1.useSchedulerGroupsContext)();
    var orientation = (0, SchedulerContext_1.useSchedulerOrientationContext)();
    var fields = (0, SchedulerContext_1.useSchedulerFieldsContext)();
    var dateRange = (0, SchedulerContext_1.useSchedulerDateRangeContext)();
    var viewStart = React.useMemo(function () { return showWorkHours
        ? workDayStart
        : startTime; }, [
        showWorkHours,
        workDayStart,
        startTime
    ]);
    var viewEnd = React.useMemo(function () { return showWorkHours
        ? workDayEnd
        : endTime; }, [
        showWorkHours,
        workDayEnd,
        endTime
    ]);
    var dayRanges = React.useMemo(function () { return (0, services_1.toRanges)(dateRange, { step: kendo_date_math_1.MS_PER_DAY * numberOfDays, timezone: timezone })
        .map(function (r) { return (__assign(__assign({}, r), { isAllDay: true })); }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        numberOfDays
    ]);
    var timeRanges = React.useMemo(function () { return (0, services_1.toRanges)(dateRange, { step: kendo_date_math_1.MS_PER_DAY, timezone: timezone })
        .map(function (r) { return (__assign(__assign({}, r), { isAllDay: false })); }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        timezone
    ]);
    var daySlots = React.useMemo(function () { return (0, services_1.toSlots)(dateRange, { step: kendo_date_math_1.MS_PER_DAY }, { groups: groups, ranges: dayRanges }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        timezone,
        dayRanges,
        groups
    ]);
    var timeSlots = React.useMemo(function () { return (0, services_1.toSlots)(dateRange, { step: (slotDuration * constants_1.MS_PER_MINUTE) / slotDivisions }, { groups: groups, ranges: timeRanges })
        .filter(function (slot) { return viewEnd.getTime() === viewStart.getTime()
        || (0, utils_1.isInTimeRange)(slot.zonedStart, viewStart, viewEnd); }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        slotDuration,
        slotDivisions,
        viewStart.getTime(),
        viewEnd.getTime(),
        groups,
        timeRanges
    ]);
    var occurrences = React.useMemo(function () { return (0, services_1.toOccurrences)(data, { dateRange: dateRange, fields: fields, timezone: timezone }); }, [data, dateRange.start.getTime(), dateRange.end.getTime(), fields, timezone]);
    var dayOccurrences = React.useMemo(function () { return occurrences.filter(function (o) { return o.isAllDay; }); }, [occurrences]);
    var timeOccurrences = React.useMemo(function () { return occurrences.filter(function (o) { return !o.isAllDay; }); }, [occurrences]);
    var dayItems = React.useMemo(function () { return (0, services_1.toItems)(dayOccurrences, { timezone: timezone }, { groups: groups, ranges: dayRanges }); }, [occurrences, timezone, groups, dayRanges]);
    var timeItems = React.useMemo(function () { return (0, services_1.toItems)(timeOccurrences, { timezone: timezone }, { groups: groups, ranges: timeRanges })
        .filter(function (item) { return viewStart.getTime() === viewEnd.getTime()
        || (0, utils_1.isInTimeRange)(item.zonedStart, viewStart, viewEnd)
        || (0, utils_1.isInTimeRange)(item.zonedEnd, viewStart, viewEnd)
        || (0, utils_1.isInTimeRange)(new Date(item.zonedEnd.getTime() - ((item.zonedEnd.getTime() - item.zonedStart.getTime()) / 2)), viewStart, viewEnd); }); }, [occurrences, timezone, groups, timeRanges, viewStart.getTime(), viewEnd.getTime()]);
    React.useMemo(function () { return (0, utils_1.mapItemsToSlots)(dayItems, daySlots, false); }, [dayItems, daySlots]);
    React.useMemo(function () { return (0, utils_1.mapSlotsToItems)(dayItems, daySlots, false); }, [dayItems, daySlots]);
    React.useMemo(function () { return (0, utils_1.mapItemsToSlots)(timeItems, timeSlots, false); }, [timeItems, timeSlots]);
    React.useMemo(function () { return (0, utils_1.mapSlotsToItems)(timeItems, timeSlots, false); }, [timeItems, timeSlots]);
    var head = (React.createElement(SchedulerResourceIteratorContext_1.SchedulerResourceIteratorContext.Consumer, null, function (_a) {
        var groupIndex = _a.groupIndex;
        return (React.createElement("div", { className: "k-scheduler-row", key: groupIndex }, timeRanges.map(function (range, rangeIndex) { return (React.createElement(DateHeaderCell_1.DateHeaderCell, { as: props.dateHeaderCell, key: rangeIndex, date: kendo_date_math_1.ZonedDate.fromLocalDate(new Date(range.zonedEnd.getTime() - ((range.zonedEnd.getTime() - range.zonedStart.getTime()) / 2)), timezone), start: range.start, end: range.end, format: { skeleton: 'MEd' } })); })));
    }));
    var allDaySlots = (React.createElement(SchedulerResourceIteratorContext_1.SchedulerResourceIteratorContext.Consumer, null, function (_a) {
        var groupIndex = _a.groupIndex;
        return (React.createElement("div", { key: groupIndex, className: "k-scheduler-row" }, dayRanges.map(function (_, rangeIndex) { return (daySlots
            .filter(function (s) { return s.group.index === groupIndex && s.range.index === rangeIndex; })
            .map(function (slot, slotIndex, filtered) { return (React.createElement(EditSlot, __assign({}, slot, { onDataAction: props.onDataAction, form: props.form, slot: props.slot, viewSlot: props.viewSlot, key: "".concat(slot.start.getTime(), ":").concat(slot.group.index), row: 0, col: orientation === 'horizontal' ? ((filtered.length * (groupIndex || 0)) + slotIndex) : slotIndex, isWorkDay: 0 <= ((slot.zonedStart.getDay() + (numberOfDays - workWeekStart)))
                && ((slot.zonedStart.getDay() + (numberOfDays - workWeekStart))
                    % numberOfDays)
                    <= ((workWeekEnd + (numberOfDays - workWeekStart))), expandable: true }))); })); })));
    }));
    var className = React.useMemo(function () { return (0, kendo_react_common_1.classNames)('k-scheduler-day-view', props.className); }, [props.className]);
    return (React.createElement(React.Fragment, null,
        React.createElement(BaseView_1.BaseView, { id: props.id, props: props, style: props.style, className: className, ranges: __spreadArray(__spreadArray([], dayRanges, true), timeRanges, true), slots: __spreadArray(__spreadArray([], daySlots, true), timeSlots, true) },
            React.createElement("div", { className: "k-scheduler-head" }, orientation === 'horizontal'
                ? React.createElement(React.Fragment, null,
                    React.createElement(HorizontalResourceIterator_1.HorizontalResourceIterator, { nested: true, group: group, resources: propResources, rowContent: DayViewGroupRowContent_1.DayViewGroupRowContent, childRowContent: DayViewGroupRowContent_1.DayViewGroupRowContent }, head),
                    React.createElement(HorizontalResourceIterator_1.HorizontalResourceIterator, { group: group, resources: propResources, rowContent: DayViewAllDayRowContent_1.DayViewAllDayRowContent, childRowContent: DayViewAllDayRowContent_1.DayViewAllDayRowContent }, allDaySlots),
                    dayItems.map(function (item) { return (React.createElement(EditItem, __assign({ key: item.isRecurring
                            ? "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index, ":").concat(item.originalStart)
                            : "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index) }, item, { form: props.form, onDataAction: props.onDataAction, item: props.item, viewItem: props.viewItem, editable: props.editable, vertical: false }))); }))
                : React.createElement(VerticalResourceIterator_1.VerticalResourceIterator, { group: group, resources: propResources, cellContent: EMPTY_CELL }, head)),
            React.createElement("div", { className: "k-scheduler-body" },
                orientation === 'horizontal'
                    ? (React.createElement(React.Fragment, null,
                        timeSlots
                            .filter(function (slot) { return slot.group.index === FIRST_INDEX && slot.range.index === FIRST_INDEX; })
                            .map(function (root, rootIndex) {
                            return (React.createElement(React.Fragment, { key: root.index },
                                React.createElement(HorizontalResourceIterator_1.HorizontalResourceIterator, { nested: false, group: group, resources: propResources, rowContent: DayViewRowContent_1.DayViewRowContent, rowContentProps: {
                                        timeHeaderCell: props.timeHeaderCell,
                                        isMaster: (rootIndex % slotDivisions === 0),
                                        isLast: ((rootIndex + 1) % slotDivisions === 0),
                                        slot: root
                                    } },
                                    React.createElement(SchedulerResourceIteratorContext_1.SchedulerResourceIteratorContext.Consumer, null, function (_a) {
                                        var groupIndex = _a.groupIndex;
                                        return (React.createElement("div", { className: (0, kendo_react_common_1.classNames)('k-scheduler-row', {
                                                'k-middle-row': !((rootIndex + 1) % slotDivisions === 0)
                                            }) }, timeRanges.map(function (_range, rangeIndex) { return (timeSlots
                                            .filter(function (s) { return s.index === root.index
                                            && s.range.index === rangeIndex
                                            && s.group.index === groupIndex; })
                                            .map(function (slot) { return (React.createElement(EditSlot, __assign({ key: "".concat(slot.start.getTime(), ":").concat(slot.group.index) }, slot, { onDataAction: props.onDataAction, slot: props.slot, viewSlot: props.viewSlot, form: props.form, row: rootIndex + GRID_OFFSET, col: (timeRanges.length * (groupIndex || 0)) + rangeIndex, isWorkHour: (0, utils_1.isInTimeRange)(slot.zonedStart, workDayStart, workDayEnd), isWorkDay: (0, utils_1.isInDaysRange)(slot.zonedEnd.getDay(), workWeekStart, workWeekEnd), editable: props.editable }))); })); })));
                                    }))));
                        }),
                        (props.currentTimeMarker
                            && (0, utils_1.intersects)((0, utils_1.first)(timeRanges).start, (0, utils_1.last)(timeRanges).end, new Date(), new Date(), true))
                            && (React.createElement(CurrentTimeMarket_1.CurrentTimeMarker, null))))
                    : React.createElement(React.Fragment, null,
                        React.createElement(VerticalResourceIterator_1.VerticalResourceIterator, { nested: true, group: group, resources: propResources },
                            React.createElement(SchedulerResourceIteratorContext_1.SchedulerResourceIteratorContext.Consumer, null, function (_a) {
                                var groupIndex = _a.groupIndex;
                                return (React.createElement(React.Fragment, { key: groupIndex },
                                    React.createElement("div", { className: "k-scheduler-row" },
                                        React.createElement(DayViewAllDayRowContent_1.DayViewAllDayRowContent, { groupIndex: groupIndex }, dayRanges.map(function (_, rangeIndex) {
                                            var groupOffset = timeSlots
                                                .filter(function (s) { return s.group.index === groupIndex && s.range.index === FIRST_INDEX; })
                                                .length;
                                            return (daySlots
                                                .filter(function (s) { return s.group.index === groupIndex && s.range.index === rangeIndex; })
                                                .map(function (slot, slotIndex) { return (React.createElement(EditSlot, __assign({ slot: props.slot, viewSlot: props.viewSlot, form: props.form }, slot, { onDataAction: props.onDataAction, key: "".concat(slot.start.getTime(), ":").concat(slot.group.index), className: 'k-scheduler-alldays-slot', row: ((groupOffset * (groupIndex || 0)))
                                                    + ((groupIndex || 0) * GRID_OFFSET), col: slotIndex, expandable: true }))); }));
                                        }))),
                                    timeSlots
                                        .filter(function (s) { return s.group.index === groupIndex && s.range.index === FIRST_INDEX; })
                                        .map(function (root, rootIndex, filtered) { return (React.createElement("div", { className: "k-scheduler-row", key: root.index },
                                        React.createElement(DayViewRowContent_1.DayViewRowContent, { slot: root, isMaster: rootIndex % slotDivisions === 0, isLast: (rootIndex + 1) % slotDivisions === 0, timeHeaderCell: props.timeHeaderCell }, timeRanges.map(function (_, rangeIndex) { return (timeSlots
                                            .filter(function (s) { return s.index === root.index
                                            && s.group.index === groupIndex
                                            && s.range.index === rangeIndex; })
                                            .map(function (slot) { return (React.createElement(EditSlot, __assign({ slot: props.slot, viewSlot: props.viewSlot, form: props.form, onDataAction: props.onDataAction }, slot, { key: "".concat(slot.start.getTime(), ":").concat(slot.group.index), row: ((filtered.length * (groupIndex || 0)) + rootIndex)
                                                + ((groupIndex || 0) * GRID_OFFSET) + GRID_OFFSET, col: rangeIndex, editable: props.editable, isWorkHour: (0, utils_1.isInTimeRange)(slot.zonedStart, workDayStart, workDayEnd), isWorkDay: 0 <= ((slot.zonedStart.getDay()
                                                + (numberOfDays - workWeekStart)))
                                                && ((slot.zonedStart.getDay()
                                                    + (numberOfDays - workWeekStart))
                                                    % numberOfDays)
                                                    <= ((workWeekEnd + (numberOfDays - workWeekStart))) }))); })); })))); }),
                                    ((props.currentTimeMarker
                                        && (0, utils_1.intersects)((0, utils_1.first)(timeRanges).start, (0, utils_1.last)(timeRanges).end, new Date(), new Date(), true)))
                                        && (React.createElement(CurrentTimeMarket_1.CurrentTimeMarker, { groupIndex: groupIndex }))));
                            })),
                        dayItems.map(function (item) { return (React.createElement(EditItem, __assign({ key: item.isRecurring
                                ? "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index, ":").concat(item.originalStart)
                                : "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index) }, item, { onDataAction: props.onDataAction, viewItem: props.viewItem, item: props.item, form: props.form, editable: props.editable, vertical: false }))); })),
                timeItems.map(function (item) { return (React.createElement(EditItem, __assign({ key: item.isRecurring
                        ? "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index, ":").concat(item.originalStart)
                        : "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index) }, item, { format: 't', onDataAction: props.onDataAction, viewItem: props.viewItem, item: props.item, form: props.form, editable: props.editable, vertical: true }))); })))));
};
exports.MultiDayView = MultiDayView;
var multiDayViewDateRange = function (_a) {
    var date = _a.date, _b = _a.numberOfDays, numberOfDays = _b === void 0 ? 1 : _b, timezone = _a.timezone;
    var normalized = kendo_date_math_1.ZonedDate.fromLocalDate(date, timezone);
    var firstDay = (0, kendo_date_math_1.getDate)(normalized);
    var lastDay = (0, kendo_date_math_1.addDays)(firstDay, numberOfDays);
    var zonedStart = kendo_date_math_1.ZonedDate.fromUTCDate((0, utils_1.toUTCDateTime)(firstDay), timezone);
    var zonedEnd = kendo_date_math_1.ZonedDate.fromUTCDate((0, utils_1.toUTCDateTime)(lastDay), timezone);
    var start = new Date(zonedStart.getTime());
    var end = new Date(zonedEnd.getTime());
    return {
        start: start,
        end: end,
        zonedStart: zonedStart,
        zonedEnd: zonedEnd
    };
};
/** @hidden */
exports.defaultProps = {
    name: 'multi-day',
    title: 'Multi Day',
    currentTimeMarker: true,
    dateRange: multiDayViewDateRange,
    selectedDateFormat: '{0:D} - {1:D}',
    selectedShortDateFormat: '{0:d} - {1:d}',
    numberOfDays: 1,
    startTime: '00:00',
    endTime: '23:59',
    isWorkDayStart: '08:00',
    isWorkDayEnd: '17:00',
    workWeekStart: kendo_date_math_1.Day.Monday,
    workWeekEnd: kendo_date_math_1.Day.Friday,
    step: 1,
    slotDivisions: 2,
    slotDuration: 60,
    showCurrentTime: true,
    defaultShowWorkHours: true
};
exports.MultiDayView.propTypes = {
    currentTimeMarker: PropTypes.bool,
    name: PropTypes.string,
    numberOfDays: PropTypes.number,
    startTime: PropTypes.string,
    endTime: PropTypes.string,
    workDayStart: PropTypes.string,
    workDayEnd: PropTypes.string,
    workWeekStart: PropTypes.number,
    workWeekEnd: PropTypes.any,
    slotDivisions: PropTypes.number,
    slotDuration: PropTypes.number,
    showWorkHours: PropTypes.bool,
    selectedDateFormat: PropTypes.string,
    selectedShortDateFormat: PropTypes.string
};
exports.MultiDayView.defaultProps = exports.defaultProps;
exports.MultiDayView.displayName = 'KendoReactSchedulerMultiDayView';
