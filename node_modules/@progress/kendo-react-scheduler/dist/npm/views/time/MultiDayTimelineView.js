"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultProps = exports.MultiDayTimelineView = void 0;
var React = require("react");
var BaseView_1 = require("../../components/BaseView");
var hooks_1 = require("../../hooks");
var kendo_date_math_1 = require("@progress/kendo-date-math");
var HorizontalResourceIterator_1 = require("../common/HorizontalResourceIterator");
var TimelineViewRowContent_1 = require("./TimelineViewRowContent");
var TimelineViewAllEventsRowContent_1 = require("./TimelineViewAllEventsRowContent");
var VerticalResourceIterator_1 = require("../common/VerticalResourceIterator");
var utils_1 = require("../../utils");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var rangeService_1 = require("../../services/rangeService");
var slotsService_1 = require("../../services/slotsService");
var occurrenceService_1 = require("../../services/occurrenceService");
var itemsService_1 = require("../../services/itemsService");
var SchedulerEditSlot_1 = require("../../slots/SchedulerEditSlot");
var constants_1 = require("../../constants");
var kendo_react_intl_1 = require("@progress/kendo-react-intl");
var SchedulerEditItem_1 = require("../../items/SchedulerEditItem");
var SchedulerContext_1 = require("../../context/SchedulerContext");
var SchedulerResourceIteratorContext_1 = require("../../context/SchedulerResourceIteratorContext");
var CurrentTimeMarket_1 = require("../../components/CurrentTimeMarket");
var DateHeaderCell_1 = require("../../components/DateHeaderCell");
var TimeHeaderCell_1 = require("../../components/TimeHeaderCell");
var TIME_FORMAT = 't';
var FIRST_INDEX = 0;
/**
 * @hidden
 */
var MultiDayTimelineView = function (props) {
    var _a = (0, SchedulerContext_1.useSchedulerPropsContext)(), group = _a.group, timezone = _a.timezone, propResources = _a.resources;
    var timeRef = React.useRef(null);
    var bodyRef = React.useRef(null);
    var EditItem = props.editItem || SchedulerEditItem_1.SchedulerEditItem;
    var EditSlot = props.editSlot || SchedulerEditSlot_1.SchedulerEditSlot;
    var element = React.useRef(null);
    var data = (0, SchedulerContext_1.useSchedulerDataContext)()[0];
    var orientation = (0, SchedulerContext_1.useSchedulerOrientationContext)();
    var groups = (0, SchedulerContext_1.useSchedulerGroupsContext)();
    var dateRange = (0, SchedulerContext_1.useSchedulerDateRangeContext)();
    var fields = (0, SchedulerContext_1.useSchedulerFieldsContext)();
    var intl = (0, kendo_react_intl_1.useInternationalization)();
    var showWorkHours = props.showWorkHours;
    var slotDivisions = props.slotDivisions || exports.defaultProps.slotDivisions;
    var slotDuration = props.slotDuration || exports.defaultProps.slotDuration;
    var workWeekStart = props.workWeekStart || exports.defaultProps.workWeekStart;
    var workWeekEnd = props.workWeekEnd || exports.defaultProps.workWeekEnd;
    var workDayStart = intl.parseDate(props.workDayStart || props.isWorkDayStart || exports.defaultProps.isWorkDayStart);
    var workDayEnd = intl.parseDate(props.workDayEnd || props.isWorkDayEnd || exports.defaultProps.isWorkDayEnd);
    var startTime = intl.parseDate(props.startTime || exports.defaultProps.startTime);
    var endTime = intl.parseDate(props.endTime || exports.defaultProps.endTime);
    var viewStart = React.useMemo(function () { return showWorkHours
        ? workDayStart
        : startTime; }, [
        showWorkHours,
        workDayStart,
        startTime
    ]);
    var viewEnd = React.useMemo(function () { return showWorkHours
        ? workDayEnd
        : endTime; }, [
        showWorkHours,
        workDayEnd,
        endTime
    ]);
    var ranges = React.useMemo(function () { return (0, rangeService_1.toRanges)(dateRange, { step: kendo_date_math_1.MS_PER_DAY, timezone: timezone }); }, [
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        timezone
    ]);
    var slots = React.useMemo(function () { return (0, slotsService_1.toSlots)(dateRange, { step: slotDuration / slotDivisions * kendo_date_math_1.MS_PER_MINUTE }, { groups: groups, ranges: ranges })
        .filter(function (slot) { return (0, utils_1.isInTimeRange)(slot.zonedStart, viewStart, viewEnd) || viewStart.getTime() === viewEnd.getTime(); }); }, [
        groups,
        ranges,
        dateRange.start.getTime(),
        dateRange.end.getTime(),
        timezone,
        slotDuration,
        slotDivisions,
        viewStart.getTime(),
        viewEnd.getTime()
    ]);
    var occurrences = React.useMemo(function () { return (0, occurrenceService_1.toOccurrences)(data, { dateRange: dateRange, fields: fields, timezone: timezone }); }, [data, dateRange.start.getTime(), dateRange.end.getTime(), fields, timezone]);
    var items = React.useMemo(function () { return (0, itemsService_1.toItems)(occurrences, { timezone: timezone }, { groups: groups, ranges: ranges })
        .filter(function (item) { return viewStart.getTime() === viewEnd.getTime()
        || (0, utils_1.isInTimeRange)(item.zonedStart, viewStart, viewEnd)
        || (0, utils_1.isInTimeRange)(item.zonedEnd, viewStart, viewEnd)
        || (0, utils_1.isInTimeRange)(new Date(item.zonedEnd.getTime() - ((item.zonedEnd.getTime() - item.zonedStart.getTime()) / 2)), viewStart, viewEnd); }); }, [occurrences, timezone, groups, ranges, viewStart.getTime(), viewEnd.getTime()]);
    React.useMemo(function () { return (0, utils_1.mapItemsToSlots)(items, slots, true); }, [items, slots]);
    React.useMemo(function () { return (0, utils_1.mapSlotsToItems)(items, slots, true); }, [items, slots]);
    var width = (orientation === 'horizontal' ? slots.length : slots.length / groups.length)
        * ((props.columnWidth || exports.defaultProps.columnWidth) + constants_1.BORDER_WIDTH);
    var head = (React.createElement(SchedulerResourceIteratorContext_1.SchedulerResourceIteratorContext.Consumer, null, function () { return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: "k-scheduler-row" }, ranges.map(function (range, rangeIndex) { return (React.createElement(DateHeaderCell_1.DateHeaderCell, { as: props.dateHeaderCell, key: rangeIndex, date: range.zonedStart, start: range.start, end: range.end, format: 'm' })); })),
        React.createElement("div", { className: "k-scheduler-row", ref: timeRef }, ranges.map(function (_, rangeIndex) {
            return slots
                .filter(function (s) { return (s.group.index === FIRST_INDEX && s.range.index === rangeIndex); })
                .map(function (slot) { return (slot.zonedStart.getMinutes() % slotDuration === 0
                ? (React.createElement(TimeHeaderCell_1.TimeHeaderCell, { key: slot.index, as: props.timeHeaderCell, format: TIME_FORMAT, date: slot.zonedStart, start: slot.zonedStart, end: slot.zonedEnd })) : null); });
        })))); }));
    var body = (React.createElement(SchedulerResourceIteratorContext_1.SchedulerResourceIteratorContext.Consumer, null, function (_a) {
        var groupIndex = _a.groupIndex;
        return (React.createElement("div", { className: "k-scheduler-row" }, ranges.map(function (_, rangeIndex) {
            return (slots
                .filter(function (s) { return s.group.index === groupIndex && s.range.index === rangeIndex; })
                .map(function (slot, slotIndex, filtered) { return (React.createElement(EditSlot, __assign({ key: "".concat(slot.start.getTime(), ":").concat(slot.group.index), slot: props.slot, viewSlot: props.viewSlot }, slot, { form: props.form, onDataAction: props.onDataAction, isWorkHour: (0, utils_1.isInTimeRange)(slot.zonedStart, workDayStart, workDayEnd), isWorkDay: (0, utils_1.isInDaysRange)(slot.zonedEnd.getDay(), workWeekStart, workWeekEnd), col: orientation === 'horizontal'
                    ? (((rangeIndex * filtered.length) + slotIndex)
                        + ((filtered.length * ranges.length) * (groupIndex || 0)))
                    : ((rangeIndex * filtered.length) + slotIndex), row: orientation === 'horizontal'
                    ? 0
                    : (groupIndex || 0), expandable: true, editable: props.editable }))); }));
        })));
    }));
    var className = React.useMemo(function () { return (0, kendo_react_common_1.classNames)('k-scheduler-timeline-view', props.className); }, [props.className]);
    (0, hooks_1.useCellSync)({
        element: element,
        selector: '.k-resource-cell',
        attribute: 'data-depth-index',
        explicitDepth: true
    });
    (0, hooks_1.useRowSync)({
        element: element,
        selector: '.k-resource-row',
        horizontalAttribute: 'data-depth-index',
        verticalAttribute: 'data-resource-index',
        applyTo: '.k-resource-cell'
    });
    return (React.createElement(React.Fragment, null,
        React.createElement(BaseView_1.BaseView, { ref: element, id: props.id, style: (__assign({}, props.style)), className: className, props: props, slots: slots, ranges: ranges },
            React.createElement("div", { className: "k-scheduler-head", style: { width: width } }, orientation === 'horizontal'
                ? React.createElement(HorizontalResourceIterator_1.HorizontalResourceIterator, { nested: true, group: group, resources: propResources, rowContent: TimelineViewRowContent_1.TimelineViewRowContent }, head)
                : React.createElement(VerticalResourceIterator_1.VerticalResourceIterator, { wrapGroup: true, group: group, resources: propResources }, head)),
            React.createElement("div", { className: "k-scheduler-body", style: { width: width }, ref: bodyRef },
                orientation === 'horizontal'
                    ? React.createElement(HorizontalResourceIterator_1.HorizontalResourceIterator, { group: group, resources: propResources, rowContent: TimelineViewAllEventsRowContent_1.TimelineViewAllEventsRowContent },
                        body,
                        React.createElement(SchedulerResourceIteratorContext_1.SchedulerResourceIteratorContext.Consumer, null, function (_a) {
                            var groupIndex = _a.groupIndex;
                            return ((props.currentTimeMarker
                                && (0, utils_1.intersects)((0, utils_1.first)(ranges).start, (0, utils_1.last)(ranges).end, new Date(), new Date(), true))
                                && (React.createElement(CurrentTimeMarket_1.CurrentTimeMarker, { groupIndex: groupIndex, attachArrow: timeRef, vertical: true })));
                        }))
                    : React.createElement(VerticalResourceIterator_1.VerticalResourceIterator, { nested: true, wrapGroup: true, group: group, resources: propResources }, body),
                (orientation === 'vertical'
                    && props.currentTimeMarker
                    && (0, utils_1.intersects)((0, utils_1.first)(ranges).start, (0, utils_1.last)(ranges).end, new Date(), new Date(), true))
                    && (React.createElement(CurrentTimeMarket_1.CurrentTimeMarker, { attachArrow: timeRef, vertical: true })),
                items
                    .sort(utils_1.orderSort)
                    .map(function (item) { return (React.createElement(EditItem, __assign({ key: item.isRecurring
                        ? "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index, ":").concat(item.originalStart)
                        : "".concat(item.uid, ":").concat(item.group.index, ":").concat(item.range.index) }, item, { format: 't', form: props.form, onDataAction: props.onDataAction, item: props.item, viewItem: props.viewItem, editable: props.editable, ignoreIsAllDay: true, vertical: false }))); })))));
};
exports.MultiDayTimelineView = MultiDayTimelineView;
var multiDayTimelineDateRange = function (_a) {
    var date = _a.date, _b = _a.numberOfDays, numberOfDays = _b === void 0 ? 1 : _b, timezone = _a.timezone;
    var normalized = kendo_date_math_1.ZonedDate.fromLocalDate(date, timezone);
    var firstDay = (0, kendo_date_math_1.getDate)(normalized);
    var lastDay = (0, kendo_date_math_1.addDays)(firstDay, numberOfDays);
    var zonedStart = kendo_date_math_1.ZonedDate.fromUTCDate((0, utils_1.toUTCDateTime)(firstDay), timezone);
    var zonedEnd = kendo_date_math_1.ZonedDate.fromUTCDate((0, utils_1.toUTCDateTime)(lastDay), timezone);
    var start = new Date(zonedStart.getTime());
    var end = new Date(zonedEnd.getTime());
    return {
        start: start,
        end: end,
        zonedStart: zonedStart,
        zonedEnd: zonedEnd
    };
};
/** @hidden */
exports.defaultProps = {
    name: 'multi-day-timeline',
    title: 'Multi Day Timeline',
    currentTimeMarker: true,
    dateRange: multiDayTimelineDateRange,
    selectedDateFormat: '{0:D} - {1:D}',
    selectedShortDateFormat: '{0:d} - {1:d}',
    step: 1,
    numberOfDays: 1,
    startTime: '00:00',
    endTime: '00:00',
    isWorkDayStart: '8:00',
    isWorkDayEnd: '17:00',
    workWeekStart: kendo_date_math_1.Day.Monday,
    workWeekEnd: kendo_date_math_1.Day.Friday,
    slotDivisions: 2,
    slotDuration: 60,
    // showCurrentTime: true // TODO: Phase 2
    defaultShowWorkHours: true,
    columnWidth: 100
};
exports.MultiDayTimelineView.defaultProps = exports.defaultProps;
