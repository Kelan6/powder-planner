"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchedulerForm = void 0;
var React = require("react");
var ReactDOM = require("react-dom");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var kendo_react_buttons_1 = require("@progress/kendo-react-buttons");
var kendo_react_form_1 = require("@progress/kendo-react-form");
var kendo_react_dialogs_1 = require("@progress/kendo-react-dialogs");
var kendo_react_intl_1 = require("@progress/kendo-react-intl");
var SchedulerFormEditor_1 = require("../editors/SchedulerFormEditor");
var context_1 = require("../context");
var messages_1 = require("../messages");
/**
 * Represents the default `form` component rendered by the [SchedulerEditItem]({% slug api_scheduler_scheduleredititem %}) and [SchedulerEditSlot]({% slug api_scheduler_schedulereditslot %}) components.
 *
 * Accepts [SchedulerFormProps]({ slug api_scheduler_schedulerformprops }) properties and provide [SchedulerFormHandle]({% slug api_scheduler_schedulerformhandle %}) `ref` callback.
 */
exports.SchedulerForm = React.forwardRef(function (props, ref) {
    var onCancel = props.onCancel, onClose = props.onClose, onSubmit = props.onSubmit, Editor = props.editor, _a = props.dialog, Dialog = _a === void 0 ? defaultProps.dialog : _a, _b = props.validator, validator = _b === void 0 ? defaultProps.validator : _b, other = __rest(props, ["onCancel", "onClose", "onSubmit", "editor", "dialog", "validator"]);
    var form = React.useRef(null);
    React.useImperativeHandle(form, function () { return ({ props: props }); });
    React.useImperativeHandle(ref, function () { return form.current; });
    var localization = (0, kendo_react_intl_1.useLocalization)();
    var fields = (0, context_1.useSchedulerFieldsContext)();
    var requiredValidationMessage = React.useMemo(function () { return localization.toLanguageString(messages_1.editorValidationRequired, messages_1.messages[messages_1.editorValidationRequired]); }, [localization]);
    var endValidationMessage = React.useMemo(function () { return localization.toLanguageString(messages_1.editorValidationEnd, messages_1.messages[messages_1.editorValidationEnd]); }, [localization]);
    var editSaveMessage = React.useMemo(function () { return localization.toLanguageString(messages_1.editorSave, messages_1.messages[messages_1.editorSave]); }, [localization]);
    var editCancelMessage = React.useMemo(function () { return localization.toLanguageString(messages_1.editorCancel, messages_1.messages[messages_1.editorCancel]); }, [localization]);
    var editorTitleMessage = React.useMemo(function () { return localization.toLanguageString(messages_1.editorTitle, messages_1.messages[messages_1.editorTitle]); }, [localization]);
    var startValidationMessage = React.useMemo(function () { return localization.toLanguageString(messages_1.editorValidationStart, messages_1.messages[messages_1.editorValidationStart]); }, [localization]);
    var handleCancel = React.useCallback(function (syntheticEvent) {
        if (onCancel) {
            onCancel.call(undefined, { value: null, syntheticEvent: syntheticEvent, target: form.current });
        }
    }, [onCancel]);
    var handleClose = React.useCallback(function (_a) {
        var syntheticEvent = _a.syntheticEvent;
        if (onClose) {
            onClose.call(undefined, { value: null, syntheticEvent: syntheticEvent, target: form.current });
        }
    }, [onClose]);
    var handleSubmit = React.useCallback(function (dataItem, syntheticEvent) {
        if (onSubmit) {
            onSubmit.call(undefined, { value: dataItem, syntheticEvent: syntheticEvent, target: form.current });
        }
    }, [onSubmit]);
    var startAfterEndValidator = React.useCallback(function (value, formValueGetter) { return (Boolean(value && formValueGetter(fields.end) && value.getTime() > formValueGetter(fields.end).getTime()) ?
        startValidationMessage :
        undefined); }, [fields, startValidationMessage]);
    var endAfterStartValidator = React.useCallback(function (value, formValueGetter) { return (Boolean(value && formValueGetter(fields.start) && value.getTime() < formValueGetter(fields.start).getTime()) ?
        endValidationMessage :
        undefined); }, [fields, endValidationMessage]);
    var requiredValidator = React.useCallback(function (value) { return (value ? undefined : requiredValidationMessage); }, [requiredValidationMessage]);
    var formValidator = React.useCallback(function (_dataItem, formValueGetter) {
        var result = {};
        result[fields.start] = [
            requiredValidator(formValueGetter(fields.start)),
            startAfterEndValidator(formValueGetter(fields.start), formValueGetter)
        ].filter(Boolean).reduce(function (current, acc) { return current || acc; }, '');
        result[fields.end] = [
            requiredValidator(formValueGetter(fields.start)),
            endAfterStartValidator(formValueGetter(fields.start), formValueGetter)
        ].filter(Boolean).reduce(function (current, acc) { return current || acc; }, '');
        var additionalValidator = validator(_dataItem, formValueGetter);
        return __assign(__assign({}, result), additionalValidator);
    }, [endAfterStartValidator, fields.end, fields.start, requiredValidator, startAfterEndValidator, validator]);
    return kendo_react_common_1.canUseDOM
        ? ReactDOM.createPortal((React.createElement(kendo_react_form_1.Form, __assign({ initialValues: props.dataItem, onSubmit: handleSubmit, validator: formValidator, render: function (renderProps) { return (React.createElement(Dialog, { title: editorTitleMessage, minWidth: 600, onClose: handleClose, className: "k-scheduler-edit-dialog" },
                React.createElement(SchedulerFormEditor_1.SchedulerFormEditor, __assign({}, renderProps, { as: Editor })),
                React.createElement(kendo_react_dialogs_1.DialogActionsBar, null,
                    React.createElement(kendo_react_buttons_1.Button, { disabled: !renderProps.allowSubmit, onClick: renderProps.onSubmit }, editSaveMessage),
                    React.createElement(kendo_react_buttons_1.Button, { onClick: handleCancel }, editCancelMessage)))); } }, other))), document && document.body)
        : null;
});
var defaultProps = {
    dialog: kendo_react_dialogs_1.Dialog,
    validator: function () { return ({}); }
};
exports.SchedulerForm.defaultProps = defaultProps;
exports.SchedulerForm.displayName = 'KendoReactSchedulerForm';
