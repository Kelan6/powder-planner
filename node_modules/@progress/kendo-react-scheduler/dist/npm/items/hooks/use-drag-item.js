"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useDragItem = exports.DRAG_ITEM_ACTION = void 0;
var kendo_react_common_1 = require("@progress/kendo-react-common");
var React = require("react");
var context_1 = require("../../context");
var useControlledState_1 = require("../../hooks/useControlledState");
var main_1 = require("../../main");
var utils_1 = require("../../utils");
/**
 * Represents the available `action` types for the `SchedulerItemDragItemAction` objects.
 *
 * The available types are:
 * - `DRAG_ITEM_SET'`
 * - `DRAG_ITEM_START'`
 * - `DRAG_ITEM_DRAG'`
 * - `DRAG_ITEM_COMPLETE'`
 * - `DRAG_ITEM_COMPLETE_OCCURRENCE'`
 * - `DRAG_ITEM_COMPLETE_SERIES'`
 * - `DRAG_ITEM_RESET'`
 * - `DRAG_ITEM_DRAG_SELECTED`
 */
var DRAG_ITEM_ACTION;
(function (DRAG_ITEM_ACTION) {
    DRAG_ITEM_ACTION["set"] = "DRAG_ITEM_SET";
    DRAG_ITEM_ACTION["start"] = "DRAG_ITEM_START";
    DRAG_ITEM_ACTION["drag"] = "DRAG_ITEM_DRAG";
    DRAG_ITEM_ACTION["complete"] = "DRAG_ITEM_COMPLETE";
    DRAG_ITEM_ACTION["completeOccurrence"] = "DRAG_ITEM_COMPLETE_OCCURRENCE";
    DRAG_ITEM_ACTION["completeSeries"] = "DRAG_ITEM_COMPLETE_SERIES";
    DRAG_ITEM_ACTION["reset"] = "DRAG_ITEM_RESET";
    DRAG_ITEM_ACTION["dragSelected"] = "DRAG_ITEM_DRAG_SELECTED";
})(DRAG_ITEM_ACTION = exports.DRAG_ITEM_ACTION || (exports.DRAG_ITEM_ACTION = {}));
;
/** @hidden */
var useDragItem = function (config, state) {
    var offset = React.useRef(0);
    var initialXRef = React.useRef(0);
    var initialYRef = React.useRef(0);
    var oldSlot = React.useRef(null);
    var _a = useControlledState_1.useControlledState.apply(void 0, state), dragItem = _a[0], setDragItem = _a[1];
    var selectedItems = (0, context_1.useSchedulerViewSelectedItemsContext)()[0];
    var fields = (0, context_1.useSchedulerFieldsContext)();
    var groups = (0, context_1.useSchedulerGroupsContext)();
    var handleDragItemAction = function (action) {
        switch (action.type) {
            case DRAG_ITEM_ACTION.set: {
                setDragItem(action.payload);
                break;
            }
            case DRAG_ITEM_ACTION.reset: {
                setDragItem(null);
                break;
            }
            case DRAG_ITEM_ACTION.dragSelected: {
                if (Math.abs(initialXRef.current - action.payload.x) < 10
                    && Math.abs(initialYRef.current - action.payload.y) < 10) {
                    return;
                }
                var slot = (0, utils_1.slotDive)(action.payload.x, action.payload.y, 7);
                if (!slot) {
                    return;
                }
                if (slot === oldSlot.current) {
                    return;
                }
                var dataItem = (0, kendo_react_common_1.clone)(config.dataItem);
                var slotStart = slot.getAttribute('data-slot-start');
                var slotIsAllDay = slot.getAttribute('data-slot-allday') === 'true';
                if (!config.ignoreIsAllDay && slotIsAllDay !== config.isAllDay) {
                    return;
                }
                var itemStart = new Date((0, utils_1.getField)(dataItem, fields.start));
                var distance_1 = Number(slotStart) - itemStart.getTime();
                var newDragItems = selectedItems.map(function (si) {
                    if (!si.current) {
                        return null;
                    }
                    var selectedDataItem = (0, kendo_react_common_1.clone)(si.current.props.dataItem);
                    var selectedStart = new Date(si.current.props.start.getTime() + distance_1);
                    var selectedEnd = new Date(si.current.props.end.getTime() + distance_1);
                    (0, utils_1.setField)(selectedDataItem, fields.start, selectedStart);
                    (0, utils_1.setField)(selectedDataItem, fields.end, selectedEnd);
                    return selectedDataItem;
                }).filter(Boolean);
                oldSlot.current = slot;
                setDragItem(__spreadArray([], newDragItems, true));
                break;
            }
            case DRAG_ITEM_ACTION.start: {
                var clientX = action.payload.x;
                var clientY = action.payload.y;
                initialXRef.current = clientX;
                initialYRef.current = clientY;
                var slot = (0, utils_1.slotDive)(clientX, clientY, 7);
                if (!slot) {
                    return;
                }
                var dataItem = (0, kendo_react_common_1.clone)(config.dataItem);
                var slotStart = slot.getAttribute('data-slot-start');
                var itemStart = (0, utils_1.getField)(dataItem, fields.start);
                if (slotStart === null) {
                    return;
                }
                offset.current = Number(slotStart) - new Date(itemStart).getTime();
                break;
            }
            case DRAG_ITEM_ACTION.drag: {
                if (Math.abs(initialXRef.current - action.payload.x) < 10
                    && Math.abs(initialYRef.current - action.payload.y) < 10) {
                    return;
                }
                var slot = (0, utils_1.slotDive)(action.payload.x, action.payload.y, 7);
                if (!slot) {
                    return;
                }
                if (slot === oldSlot.current) {
                    return;
                }
                var dataItem_1 = (0, kendo_react_common_1.clone)(config.dataItem);
                var slotStart = slot.getAttribute('data-slot-start');
                var slotGroupIndex_1 = slot.getAttribute('data-slot-group');
                var slotIsAllDay = slot.getAttribute('data-slot-allday') === 'true';
                if (!config.ignoreIsAllDay && slotIsAllDay !== config.isAllDay) {
                    return;
                }
                var itemStart = new Date((0, utils_1.getField)(dataItem_1, fields.start));
                var itemEnd = new Date((0, utils_1.getField)(dataItem_1, fields.end));
                var duration = itemEnd.getTime() - itemStart.getTime();
                var start = new Date(Number(slotStart) - Number(offset.current));
                var end = new Date(Number(slotStart) - Number(offset.current) + duration);
                var group = groups.find(function (g) { return g.index === Number(slotGroupIndex_1); });
                (0, utils_1.setField)(dataItem_1, fields.start, start);
                (0, utils_1.setField)(dataItem_1, fields.end, end);
                if (group && groups.length > 1) {
                    group.resources.forEach(function (resource) {
                        if (!resource.multiple) {
                            (0, utils_1.setField)(dataItem_1, resource.field, resource[resource.valueField]);
                        }
                    });
                }
                oldSlot.current = slot;
                if (dataItem_1) {
                    setDragItem(dataItem_1);
                }
                break;
            }
            case DRAG_ITEM_ACTION.complete: {
                setDragItem(null);
                if (config.onDataAction && dragItem) {
                    config.onDataAction.call(undefined, {
                        type: main_1.DATA_ACTION.update,
                        series: false,
                        dataItem: dragItem
                    });
                }
                break;
            }
            case DRAG_ITEM_ACTION.completeOccurrence: {
                var newDataItem = Array.isArray(dragItem) ? dragItem.slice() : (0, kendo_react_common_1.clone)(dragItem);
                setDragItem(null);
                if (config.onDataAction && dragItem) {
                    config.onDataAction.call(undefined, {
                        type: main_1.DATA_ACTION.update,
                        series: false,
                        dataItem: newDataItem
                    });
                }
                break;
            }
            case DRAG_ITEM_ACTION.completeSeries: {
                var newDataItems = void 0;
                if (Array.isArray(dragItem)) {
                    newDataItems = dragItem.map(function (di) {
                        var updated = (0, kendo_react_common_1.clone)(di);
                        (0, utils_1.setField)(updated, fields.start, (0, utils_1.getField)(di, fields.start));
                        (0, utils_1.setField)(updated, fields.end, (0, utils_1.getField)(di, fields.end));
                        return updated;
                    });
                }
                else {
                    var updated = (0, kendo_react_common_1.clone)(dragItem);
                    (0, utils_1.setField)(updated, fields.start, (0, utils_1.getField)(dragItem, fields.start));
                    (0, utils_1.setField)(updated, fields.end, (0, utils_1.getField)(dragItem, fields.end));
                    newDataItems = updated;
                }
                setDragItem(null);
                if (config.onDataAction && newDataItems) {
                    config.onDataAction.call(undefined, {
                        type: main_1.DATA_ACTION.update,
                        series: true,
                        dataItem: newDataItems
                    });
                }
                break;
            }
            default:
                setDragItem(dragItem);
                break;
        }
    };
    return [dragItem, setDragItem, handleDragItemAction];
};
exports.useDragItem = useDragItem;
