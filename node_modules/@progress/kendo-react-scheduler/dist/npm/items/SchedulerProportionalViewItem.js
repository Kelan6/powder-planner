"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchedulerProportionalViewItem = void 0;
var React = require("react");
var SchedulerItem_1 = require("./SchedulerItem");
var utils_1 = require("../utils");
var context_1 = require("../context");
var utils_2 = require("../views/common/utils");
var constants_1 = require("../constants");
var kendo_react_intl_1 = require("@progress/kendo-react-intl");
var SchedulerItemContent_1 = require("./SchedulerItemContent");
var ITEMS_SPACING = 1;
/* eslint-disable max-len */
/**
 * Represents a customized `viewItem` component which position itself proportionally to the duration of the item.
 *
 * This is a composite component of the [`SchedulerItem`]({% slug api_scheduler_scheduleritem %}), extending it to provide extended positioning inside a view.
 */
exports.SchedulerProportionalViewItem = React.forwardRef(function (props, ref) {
    // tslint:enable:max-line-length
    var itemProp = props.item, _ref = props._ref, itemRef = props.itemRef, itemProps = __rest(props, ["item", "_ref", "itemRef"]);
    var timeout = React.useRef();
    var item = React.useRef(null);
    var viewItem = React.useRef(null);
    var schedulerRect = React.useRef(null);
    React.useImperativeHandle(viewItem, function () { return ({ props: props, element: item.current && item.current.element }); });
    React.useImperativeHandle(ref, function () { return viewItem.current; });
    React.useImperativeHandle(_ref, function () { return item.current; });
    React.useImperativeHandle(itemRef, function () { return item.current; });
    var Item = itemProp || defaultProps.item;
    var intl = (0, kendo_react_intl_1.useInternationalization)();
    var viewItems = (0, context_1.useSchedulerViewItemsContext)()[0];
    var viewSlots = (0, context_1.useSchedulerViewSlotsContext)()[0];
    var scheduler = (0, context_1.useSchedulerElementContext)();
    var _a = React.useState(true), display = _a[0], setDisplay = _a[1];
    var _b = React.useState(false), visible = _b[0], setVisible = _b[1];
    var _c = React.useState(0), maxSiblingsPerSlot = _c[0], setMaxSiblingsPerSlot = _c[1];
    var itemTime = React.useMemo(function () { return props.isAllDay
        ? intl.toString(props.zonedStart, 't')
        : intl.format('{0:t} - {1:t}', props.zonedStart, props.zonedEnd); }, [intl, props.isAllDay, props.zonedEnd, props.zonedStart]);
    var itemTitle = React.useMemo(function () { return "(".concat(itemTime, "): ").concat(props.title); }, [itemTime, props.title]);
    var calculateMostSiblings = function (slots, items) {
        var most = 1;
        slots.forEach(function (slot) {
            var itemsInSlot = items.filter(function (i) { return inSlot(slot.current.props, i.props); });
            if (itemsInSlot.length > most) {
                most = itemsInSlot.length;
            }
        });
        return most;
    };
    var getSiblingsInAllSlots = function (slots, items) {
        var siblings = slots.map(function (slot) {
            return items.filter(function (i) { return inSlot(slot.current.props, i.props); });
        });
        return siblings;
    };
    var inSlot = function (slot, current) {
        return (0, utils_1.intersects)(slot.start, slot.end, current.start, current.end)
            && slot.group.index === current.group.index
            && slot.range.index === current.range.index
            && (props.ignoreIsAllDay || slot.isAllDay === current.isAllDay);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    var align = function () {
        var slots = (viewSlots || []).filter(function (slot) { return slot.current && inSlot(slot.current.props, props); });
        if (slots.length === 0) {
            setDisplay(false);
            return;
        }
        var firstSlot = (0, utils_1.first)(slots);
        if (!firstSlot.current || !item.current) {
            return;
        }
        var rect = (0, utils_2.getRect)(firstSlot.current.element);
        (0, utils_2.setRect)(item.current.element, rect);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    var position = function () {
        var slots = (viewSlots || []).filter(function (slot) { return slot.current && inSlot(slot.current.props, props); });
        var element = item.current && item.current.element;
        if (!element) {
            return;
        }
        var firstSlot = (0, utils_1.first)(slots);
        var lastSlot = (0, utils_1.last)(slots);
        if (!firstSlot.current || !item.current || !lastSlot.current) {
            return;
        }
        var items = [];
        var dragItems = [];
        var resizeItems = [];
        var slotRect = (0, utils_2.getRect)(firstSlot.current.element);
        var pxPerMillisecond = (props.vertical ? slotRect.height : slotRect.width) /
            (firstSlot.current.props.end.getTime() - firstSlot.current.props.start.getTime());
        var offset = (props.start.getTime() - firstSlot.current.props.start.getTime()) * pxPerMillisecond;
        var total = (Math.min(props.end.getTime(), lastSlot.current.props.end.getTime()) - Math.max(props.start.getTime(), firstSlot.current.props.start.getTime())) * pxPerMillisecond;
        (viewItems || []).forEach(function (i) {
            if (!i.current) {
                return;
            }
            if (i.current.props.dragHint) {
                dragItems.push(i.current);
            }
            else if (i.current.props.resizeHint) {
                resizeItems.push(i.current);
            }
            else {
                items.push(i.current);
            }
        });
        var order = (props.dragHint || props.resizeHint)
            ? (0, utils_1.calculateOrder)(item.current, props.dragHint ? dragItems : resizeItems, slots, props.ignoreIsAllDay)
            : (props.order || 0);
        var mostSiblingsInSlot = props.dragHint || props.resizeHint
            ? calculateMostSiblings(slots, props.dragHint ? dragItems : resizeItems)
            : calculateMostSiblings(slots, items);
        var siblingsPerSlot = getSiblingsInAllSlots(slots, items);
        var topOffset = 0;
        var rect = (0, utils_2.getRect)(element);
        siblingsPerSlot.forEach(function (slot) {
            var currentOffset = 0;
            slot.forEach(function (current) {
                if ((0, utils_1.intersects)(current.props.start, current.props.end, props.start, props.end)
                    && !(props.dragHint || props.resizeHint)
                    && current.props._maxSiblingsPerSlot
                    && current.props._maxSiblingsPerSlot > mostSiblingsInSlot
                    && current.element !== element) {
                    mostSiblingsInSlot = current.props._maxSiblingsPerSlot;
                }
                var currentRect = (0, utils_2.getRect)(current.element);
                if (current.props.order !== null && current.props.order < order) {
                    currentOffset = ((currentRect.top + currentRect.height) - rect.top) - (constants_1.BORDER_WIDTH * order) + ITEMS_SPACING;
                }
            });
            if (currentOffset > topOffset) {
                topOffset = currentOffset;
            }
        });
        if (slots.length === 0) {
            setDisplay(false);
            return;
        }
        var OFFSET = 20;
        rect.width = (props.vertical
            ? ((rect.width / mostSiblingsInSlot) - constants_1.BORDER_WIDTH - (OFFSET / mostSiblingsInSlot))
            : ((total) + (constants_1.BORDER_WIDTH)));
        rect.height = props.vertical
            ? (total - (constants_1.BORDER_WIDTH))
            : ((props.resizeHint || props.dragHint) && mostSiblingsInSlot <= 1)
                ? rect.height
                : (props.style && props.style.height ? props.style.height : 25);
        rect.left = props.vertical
            ? (rect.left + (order * rect.width) + (constants_1.BORDER_WIDTH * order))
            : rect.left + (offset < 0 ? 0 : offset);
        rect.top = props.vertical
            ? rect.top + (offset < 0 ? 0 : offset)
            : (rect.top + topOffset + (constants_1.BORDER_WIDTH * order));
        setMaxSiblingsPerSlot(mostSiblingsInSlot);
        (0, utils_2.setRect)(element, rect);
        setVisible(true);
        setDisplay(true);
    };
    var handleResize = React.useCallback(function (entries) {
        var entry = entries && entries[0];
        var rect = schedulerRect.current;
        if (timeout.current !== undefined) {
            window.cancelAnimationFrame(timeout.current);
        }
        if (rect && entry &&
            (rect.width !== entry.contentRect.width ||
                rect.height !== entry.contentRect.height)) {
            timeout.current = window.requestAnimationFrame(function () {
                align();
                position();
            });
        }
        schedulerRect.current = { width: entry.contentRect.width, height: entry.contentRect.height };
    }, [align, position]);
    React.useEffect(align);
    React.useEffect(position);
    React.useEffect(function () {
        if (!scheduler.current) {
            return;
        }
        var observer = new window.ResizeObserver(handleResize);
        observer.observe(scheduler.current);
        return function () {
            observer.disconnect();
        };
    }, [handleResize, scheduler]);
    return (React.createElement(Item, __assign({}, itemProps, { _ref: item, _maxSiblingsPerSlot: maxSiblingsPerSlot, itemRef: item, style: __assign({ visibility: visible ? undefined : 'hidden', display: display ? undefined : 'none' }, props.style) }),
        (!props.resizeHint) && React.createElement("span", { className: "k-event-actions" },
            props.tail && React.createElement("span", { className: "k-icon k-i-caret-alt-left" }),
            (props.isRecurring && !props.isException) && React.createElement("span", { className: "k-icon k-i-reload" }),
            (!props.isRecurring && props.isException) && React.createElement("span", { className: "k-icon k-i-non-recurrence" })),
        (!props.resizeHint) && (React.createElement("div", { title: itemTitle },
            !props.isAllDay && (React.createElement(SchedulerItemContent_1.SchedulerItemContent, { className: "k-event-template k-event-time " }, itemTitle)),
            React.createElement(SchedulerItemContent_1.SchedulerItemContent, { className: "k-event-template" }, props.title)))));
});
var defaultProps = {
    item: SchedulerItem_1.SchedulerItem
};
exports.SchedulerProportionalViewItem.defaultProps = defaultProps;
exports.SchedulerProportionalViewItem.displayName = 'KendoReactSchedulerProportionalViewItem';
