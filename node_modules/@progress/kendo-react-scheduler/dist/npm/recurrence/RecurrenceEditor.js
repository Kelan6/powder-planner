"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RecurrenceEditor = void 0;
var React = require("react");
var kendo_react_intl_1 = require("@progress/kendo-react-intl");
var messages_1 = require("../messages");
var kendo_recurrence_1 = require("@progress/kendo-recurrence");
var kendo_date_math_1 = require("@progress/kendo-date-math");
var RecurrenceFrequencyEditor_1 = require("./RecurrenceFrequencyEditor");
var RecurrenceRepeatOnWeekEditor_1 = require("./RecurrenceRepeatOnWeekEditor");
var common_1 = require("./common");
var kendo_react_labels_1 = require("@progress/kendo-react-labels");
var kendo_react_inputs_1 = require("@progress/kendo-react-inputs");
var kendo_react_dropdowns_1 = require("@progress/kendo-react-dropdowns");
var kendo_react_dateinputs_1 = require("@progress/kendo-react-dateinputs");
var context_1 = require("../context");
/** @hidden */
var RecurrenceEditor = function (props) {
    var intl = (0, kendo_react_intl_1.useInternationalization)();
    var localization = (0, kendo_react_intl_1.useLocalization)();
    var timezone = (0, context_1.useSchedulerPropsContext)().timezone;
    var _a = React.useState(1), defaultCount = _a[0], setDefaultCount = _a[1];
    var _b = React.useState(kendo_date_math_1.ZonedDate.fromUTCDate(props.start)), defaultUntil = _b[0], setDefaultUntil = _b[1];
    var localizeMessage = React.useCallback(function (baseMassage, removePrepend) {
        var message = removePrepend ? baseMassage : 'scheduler.recurrenceEditor' + baseMassage;
        return localization.toLanguageString(message, messages_1.messages[message]);
    }, [localization]);
    var rrule = React.useMemo(function () { return (0, common_1.getRule)(props.value); }, [props.value]);
    var frequencies = React.useMemo(function () { return (0, common_1.getFrequencies)(localizeMessage); }, [localizeMessage]);
    var frequency = React.useMemo(function () { return (0, common_1.getFrequency)(rrule); }, [rrule]);
    var extendedWeekDays = React.useMemo(function () { return (0, common_1.getExtendedWeekDays)(intl, localizeMessage); }, [intl, localizeMessage]);
    var weekDay = React.useMemo(function () { return (0, common_1.getWeekDay)(extendedWeekDays, rrule, props.start); }, [extendedWeekDays, rrule, props.start]);
    var months = React.useMemo(function () { return (0, common_1.getMonths)(intl); }, [intl]);
    var month = React.useMemo(function () { return (0, common_1.getMonth)(months, rrule); }, [months, rrule]);
    var offsets = React.useMemo(function () { return (0, common_1.getOffsets)(localizeMessage); }, [localizeMessage]);
    var offset = React.useMemo(function () { return (0, common_1.getOffset)(offsets, rrule); }, [offsets, rrule]);
    var endRule = React.useMemo(function () { return (0, common_1.getEndRule)(rrule); }, [rrule]);
    var monthDay = React.useMemo(function () { return (0, common_1.getMonthDay)(rrule, props.start); }, [rrule, props.start]);
    var until = React.useMemo(function () { return (0, common_1.getUntil)(rrule); }, [rrule.until]);
    var weekDays = React.useMemo(function () { return (0, common_1.getWeekDays)(intl); }, [intl]);
    var repeatOnRule = React.useMemo(function () { return (0, common_1.getRepeatOnRule)(rrule); }, [rrule.byWeekDay, rrule.byMonthDay]);
    var onChangeHandler = React.useCallback(function (newRrule) {
        if (newRrule.freq === 'never') {
            props.onChange({ value: null });
        }
        else {
            if (newRrule.weekStart === undefined) {
                newRrule.weekStart = intl.firstDay();
            }
            props.onChange({ value: (0, kendo_recurrence_1.serializeRule)(newRrule, props.timezone) });
        }
    }, [props.onChange, props.timezone]);
    var handleFrequencyChange = React.useCallback(function (newFreq) {
        var newRrule = {};
        newRrule.freq = newFreq;
        newRrule.interval = 1;
        if (newFreq === 'weekly') {
            newRrule.byWeekDay = [{
                    day: kendo_date_math_1.ZonedDate.fromLocalDate(props.start, timezone).getDay(),
                    offset: 0
                }];
        }
        if (newFreq === 'monthly' || newFreq === 'yearly') {
            newRrule.byMonthDay = [props.start.getDate()];
        }
        if (newFreq === 'yearly') {
            newRrule.byMonth = [props.start.getMonth() + 1];
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, props.start, timezone]);
    var handleIntervalChange = React.useCallback(function (event) {
        var newInterval = event.value;
        onChangeHandler(Object.assign({}, rrule, {
            interval: newInterval
        }));
    }, [onChangeHandler, rrule]);
    var handleCountChange = React.useCallback(function (event) {
        var newCount = event.value;
        onChangeHandler(Object.assign({}, rrule, {
            count: newCount
        }));
        if (newCount !== null) {
            setDefaultCount(newCount);
        }
    }, [onChangeHandler, rrule]);
    var handleUntilChange = React.useCallback(function (event) {
        var newUntil = event.value;
        if (!newUntil) {
            return;
        }
        var value = kendo_date_math_1.ZonedDate.fromLocalDate(newUntil, props.timezone);
        onChangeHandler(Object.assign({}, rrule, {
            until: value
        }));
        setDefaultUntil(value);
    }, [onChangeHandler, rrule, props.timezone]);
    var handleWeekDaysChange = React.useCallback(function (newWeekDays) {
        onChangeHandler(Object.assign({}, rrule, {
            byWeekDay: weekDays
                .filter(function (wd) { return newWeekDays.some(function (nwd) { return nwd === wd.value; }); })
                .map(function (wd) { return ({ offset: 0, day: wd.value }); })
        }));
    }, [onChangeHandler, rrule, weekDays]);
    var handleWeekDayChange = React.useCallback(function (event) {
        var newRrule = Object.assign({}, rrule);
        var newWeekDay = event.target.value;
        if (typeof newWeekDay.value === 'string') {
            /* day, weekday or weekend */
            newRrule.byWeekDay = (0, common_1.weekDayRuleFromString)(newWeekDay.value);
            newRrule.bySetPosition = [offset.value];
        }
        else {
            /* specific weekday */
            newRrule.byWeekDay = [{
                    day: newWeekDay.value,
                    offset: offset.value
                }];
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, rrule]);
    var handleMonthDayChange = React.useCallback(function (event) {
        onChangeHandler(Object.assign({}, rrule, {
            byMonthDay: [event.value]
        }));
    }, [onChangeHandler, rrule]);
    var handleMonthChange = React.useCallback(function (event) {
        var newMonth = event.value;
        onChangeHandler(Object.assign({}, rrule, {
            byMonth: [newMonth.value]
        }));
    }, [onChangeHandler, rrule]);
    var handleEndRuleChange = React.useCallback(function (event) {
        var newEnd = event.value;
        var newRrule = Object.assign({}, rrule);
        switch (newEnd) {
            case 'never':
                newRrule.until = undefined;
                newRrule.count = undefined;
                break;
            case 'count':
                newRrule.until = undefined;
                newRrule.count = defaultCount;
                break;
            case 'until':
                newRrule.until = defaultUntil;
                newRrule.count = undefined;
                break;
            default:
                break;
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, rrule, props.timezone]);
    var handleRepeatOnRuleChange = React.useCallback(function (event) {
        var newRrule = Object.assign({}, rrule);
        if (event.value === 'monthday') {
            newRrule.byWeekDay = undefined;
            newRrule.bySetPosition = undefined;
            newRrule.byMonthDay = [monthDay];
        }
        else if (event.value === 'weekday') {
            // weekDays
            newRrule.byMonthDay = undefined;
            if (typeof weekDay.value === 'string') {
                /* day, weekday or weekend */
                newRrule.bySetPosition = [offset.value];
                newRrule.byWeekDay = (0, common_1.weekDayRuleFromString)(weekDay.value);
            }
            else {
                /* specific weekday */
                newRrule.byWeekDay = [{
                        day: weekDay.value,
                        offset: offset.value
                    }];
            }
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, rrule, monthDay, weekDay]);
    var handleOffsetChange = React.useCallback(function (event) {
        var newRrule = Object.assign({}, rrule);
        var newOffset = event.value;
        if (newRrule.byWeekDay) {
            var weekDaysCount = newRrule.byWeekDay.length;
            switch (weekDaysCount) {
                case 7:
                case 5:
                case 2:
                    newRrule.bySetPosition = [newOffset.value];
                    break;
                case 1:
                    newRrule.byWeekDay[0].offset = newOffset.value;
                    break;
                default:
                    break;
            }
        }
        onChangeHandler(newRrule);
    }, [onChangeHandler, rrule]);
    return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: "k-form-field" },
            React.createElement(kendo_react_labels_1.Label, null, localization.toLanguageString(messages_1.recurrenceEditorRepeat, messages_1.messages[messages_1.recurrenceEditorRepeat])),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(RecurrenceFrequencyEditor_1.RecurrenceFrequencyEditor, { value: frequency, data: frequencies, onChange: handleFrequencyChange }))),
        (frequency !== 'never') && (React.createElement("div", { className: 'k-form-field' },
            React.createElement(kendo_react_labels_1.Label, { editorId: "interval-editor" }, localizeMessage((0, common_1.capitalize)(frequency) + 'RepeatEvery')),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement("div", { style: { display: 'flex', alignItems: 'center' } },
                    React.createElement(kendo_react_inputs_1.NumericTextBox, { min: 1, step: 1, defaultValue: 1, value: rrule.interval, onChange: handleIntervalChange, id: "interval-editor" }),
                    "\u00A0",
                    React.createElement(kendo_react_labels_1.Label, { editorId: "interval-editor" }, localizeMessage((0, common_1.capitalize)(frequency) + 'Interval')))))),
        (frequency === 'weekly') && (React.createElement("div", { className: "k-form-field" },
            React.createElement(kendo_react_labels_1.Label, null, localizeMessage(messages_1.recurrenceEditorWeeklyRepeatOn, true)),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(RecurrenceRepeatOnWeekEditor_1.RecurrenceRepeatOnWeekEditor, { data: weekDays, value: (rrule.byWeekDay || []).map(function (_a) {
                        var day = _a.day;
                        return day;
                    }), onChange: handleWeekDaysChange })))),
        (frequency === 'monthly') && (React.createElement("div", { className: "k-form-field" },
            React.createElement(kendo_react_labels_1.Label, { key: "recurrence-repeat-on-monthly-label" }, localizeMessage(messages_1.recurrenceEditorMonthlyRepeatOn, true)),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(kendo_react_inputs_1.RadioGroup, { value: repeatOnRule, onChange: handleRepeatOnRuleChange, item: RadioGroupListItem, className: "k-reset", data: [
                        {
                            value: 'monthday',
                            label: localizeMessage(messages_1.recurrenceEditorMonthlyDay, true),
                            children: [
                                React.createElement(React.Fragment, { key: "separator" }, "\u00A0"),
                                React.createElement(kendo_react_inputs_1.NumericTextBox, { key: 'weekday-day', min: 1, max: 31, disabled: repeatOnRule !== 'monthday', value: rrule && rrule.byMonthDay && rrule.byMonthDay[0], onChange: handleMonthDayChange, width: 'auto' })
                            ]
                        },
                        {
                            value: 'weekday',
                            label: ' ',
                            children: [
                                React.createElement(kendo_react_dropdowns_1.DropDownList, { key: "weekday-offset", textField: "text", dataItemKey: "value", disabled: repeatOnRule !== 'weekday', data: offsets, value: offset, onChange: handleOffsetChange, style: { width: 'auto' } }),
                                React.createElement(React.Fragment, { key: "separator" }, "\u00A0"),
                                React.createElement(kendo_react_dropdowns_1.DropDownList, { key: "weekday-value", disabled: repeatOnRule !== 'weekday', value: weekDay, data: extendedWeekDays, onChange: handleWeekDayChange, textField: "text", dataItemKey: "value", style: { width: 'auto' } })
                            ]
                        }
                    ] })))),
        (frequency === 'yearly') && (React.createElement("div", { className: "k-form-field" },
            React.createElement(kendo_react_labels_1.Label, null, localizeMessage(messages_1.recurrenceEditorYearlyRepeatOn, true)),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(kendo_react_inputs_1.RadioGroup, { value: repeatOnRule, item: RadioGroupListItem, onChange: handleRepeatOnRuleChange, className: "k-reset", data: [
                        {
                            value: 'monthday',
                            label: ' ',
                            children: [
                                React.createElement(kendo_react_dropdowns_1.DropDownList, { key: "monthday-month", disabled: repeatOnRule !== 'monthday', value: month, data: months, textField: "text", dataItemKey: "value", onChange: handleMonthChange, style: { width: 'auto' } }),
                                React.createElement(React.Fragment, { key: "separator" }, "\u00A0"),
                                React.createElement(kendo_react_inputs_1.NumericTextBox, { key: "monthday-day", min: 1, max: 31, disabled: repeatOnRule !== 'monthday', value: monthDay, onChange: handleMonthDayChange, width: 'auto' })
                            ]
                        },
                        {
                            value: 'weekday',
                            label: ' ',
                            children: [
                                React.createElement(kendo_react_dropdowns_1.DropDownList, { key: "yearly-weekday-offset", textField: "text", dataItemKey: "value", disabled: repeatOnRule !== 'weekday', data: offsets, value: offset, onChange: handleOffsetChange, style: { width: 'auto' } }),
                                React.createElement(React.Fragment, { key: "yearly-separator-1" }, "\u00A0"),
                                React.createElement(kendo_react_dropdowns_1.DropDownList, { key: "yearly-weekday-day", textField: "text", dataItemKey: "value", disabled: repeatOnRule !== 'weekday', value: weekDay, data: extendedWeekDays, onChange: handleWeekDayChange, style: { width: 'auto' } }),
                                React.createElement(React.Fragment, { key: "yearly-separator-2" }, "\u00A0"),
                                React.createElement("span", { key: "yearly-weekday-of-label" },
                                    localizeMessage(messages_1.recurrenceEditorYearlyOf, true),
                                    "\u00A0"),
                                React.createElement(React.Fragment, { key: "yearly-separator-3" }, "\u00A0"),
                                React.createElement(kendo_react_dropdowns_1.DropDownList, { key: "yearly-weekday-month", textField: "text", dataItemKey: "value", disabled: repeatOnRule !== 'weekday', value: month, data: months, onChange: handleMonthChange, style: { width: 'auto' } })
                            ]
                        }
                    ] })))),
        (frequency !== 'never') && (React.createElement("div", { className: "k-form-field" },
            React.createElement(kendo_react_labels_1.Label, null, localizeMessage(messages_1.recurrenceEditorEndLabel, true)),
            React.createElement("div", { className: "k-form-field-wrap" },
                React.createElement(kendo_react_inputs_1.RadioGroup, { item: RadioGroupListItem, value: endRule, onChange: handleEndRuleChange, data: [
                        {
                            value: 'never',
                            label: localizeMessage(messages_1.recurrenceEditorEndNever, true)
                        },
                        {
                            value: 'count',
                            label: localizeMessage(messages_1.recurrenceEditorEndAfter, true),
                            children: [
                                React.createElement(React.Fragment, { key: "separator-1" }, "\u00A0"),
                                React.createElement(kendo_react_inputs_1.NumericTextBox, { key: "endrule-after-editor", id: "k-endrule-after", min: 1, width: '70px', value: endRule === 'count' ? rrule.count : defaultCount, onChange: handleCountChange, disabled: endRule !== 'count' }),
                                React.createElement(React.Fragment, { key: "separator-2" }, "\u00A0"),
                                React.createElement(kendo_react_labels_1.Label, { key: "endrule-after-label", className: 'k-radio-label', editorId: 'k-endrule-after' }, localizeMessage(messages_1.recurrenceEditorEndOccurrence, true))
                            ]
                        },
                        {
                            value: 'until',
                            label: localizeMessage(messages_1.recurrenceEditorEndOn, true),
                            children: [
                                React.createElement(React.Fragment, { key: "separator" }, "\u00A0"),
                                React.createElement(kendo_react_dateinputs_1.DatePicker, { key: "k-endrule-until-editor", id: "k-endrule-until", disabled: endRule !== 'until', min: props.start, value: endRule === 'until' ? until : (0, kendo_date_math_1.toLocalDate)(defaultUntil), onChange: handleUntilChange, width: 'auto' })
                            ]
                        }
                    ] }))))));
};
exports.RecurrenceEditor = RecurrenceEditor;
var RadioGroupListItem = function (props) {
    return (React.createElement("li", __assign({}, props, { style: { display: 'flex', alignItems: 'center', minHeight: 30 } }), props.children));
};
exports.RecurrenceEditor.defaultProps = {
    value: ''
};
exports.RecurrenceEditor.displayName = 'KendoReactSchedulerRepeatEditor';
