"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inRange = exports.inSlot = exports.inGroup = exports.toItems = void 0;
var React = require("react");
var utils_1 = require("../utils");
var kendo_data_query_1 = require("@progress/kendo-data-query");
var kendo_date_math_1 = require("@progress/kendo-date-math");
/** @hidden */
var toItems = function (occurrences, _a, _b) {
    var timezone = _a.timezone;
    var groups = _b.groups, ranges = _b.ranges;
    var result = [];
    var sorted = (0, kendo_data_query_1.orderBy)(occurrences, [
        { field: 'start', dir: 'asc' },
        { field: 'end', dir: 'desc' },
        { field: 'isAllDay', dir: 'desc' }
    ]);
    sorted.forEach(function (occurrence) {
        groups.forEach(function (g) {
            var group = groups.length === 1
                ? personalizedGroup(occurrence, g)
                : g;
            if ((0, exports.inGroup)(occurrence, group)) {
                ranges.forEach(function (range) {
                    if ((0, exports.inRange)(occurrence, range)) {
                        var itemRef = React.createRef();
                        var _ref = React.createRef();
                        var head = range.end < occurrence.end;
                        var tail = occurrence.start < range.start;
                        var zonedStart = kendo_date_math_1.ZonedDate.fromLocalDate(occurrence.start, timezone);
                        var zonedEnd = kendo_date_math_1.ZonedDate.fromLocalDate(occurrence.end, timezone);
                        var item = __assign(__assign({}, occurrence), { _ref: _ref, itemRef: itemRef, head: head, tail: tail, order: null, zonedStart: zonedStart, zonedEnd: zonedEnd, group: group, range: range, slots: [], isRecurring: Boolean(occurrence.recurrenceRule), isException: Boolean(!occurrence.recurrenceRule
                                && occurrence.recurrenceId !== null && occurrence.recurrenceId !== undefined), isAllDay: Boolean(occurrence.isAllDay) });
                        result.push(item);
                    }
                });
            }
        });
    });
    return result;
};
exports.toItems = toItems;
var personalizedGroup = function (occurrence, group) {
    return {
        index: 0,
        resources: group.resources.filter(function (resource) { return inResource(occurrence, resource); })
    };
};
var inResource = function (occurrence, resource) {
    return resource.multiple
        ? (occurrence.dataItem[resource.field] || []).some(function (val) { return resource[resource.valueField] === val; })
        : occurrence.dataItem[resource.field] === resource[resource.valueField];
};
/** @hidden */
var inGroup = function (occurrence, group) {
    return !group.resources.some(function (res) { return res.multiple
        ? !occurrence.dataItem[res.field].some(function (val) { return res[res.valueField] === val; })
        : occurrence.dataItem[res.field] !== res[res.valueField]; });
};
exports.inGroup = inGroup;
/** @hidden */
var inSlot = function (occurrence, slot) {
    return (0, utils_1.intersects)(slot.start, slot.end, occurrence.start, occurrence.end);
};
exports.inSlot = inSlot;
/** @hidden */
var inRange = function (occurrence, range) {
    return (0, utils_1.intersects)(range.start, range.end, occurrence.start, occurrence.end)
        && (range.isAllDay === undefined
            || occurrence.isAllDay === undefined
            || (occurrence.isAllDay === range.isAllDay));
};
exports.inRange = inRange;
